<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blini.io - JavaScript, AngularJS, Ionic, PWA, Node, Express, .NET e tudo sobre web</title>
    <description>blini.io - JavaScript, AngularJS, Ionic, PWA, Node, Express, .NET e tudo sobre web
</description>
    <link>http://blini.io/</link>
    <atom:link href="http://blini.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 18 Apr 2017 23:46:55 -0300</pubDate>
    <lastBuildDate>Tue, 18 Apr 2017 23:46:55 -0300</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>O Couchbase e suas Diferenças do MongoDB</title>
        <description>&lt;p&gt;O &lt;strong&gt;MongoDB&lt;/strong&gt; e o &lt;strong&gt;Couchbase&lt;/strong&gt; fazem parte do mundo &lt;strong&gt;NoSql (Not only SQL)&lt;/strong&gt; que é composto
por uma vasta gama de bancos de dados, cada com sua especialidade. Temos bancos
especializados em documentos, especialistas em chave-valor, especialistas em grafos,
temos os que armazenam dados em colunas e por aí vai. Todos com algo em comum: &lt;strong&gt;garantir escalabilidade!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;Couchbase&lt;/strong&gt; se garante muito bem sendo um dos líderes do segmento e é usado por apps e
sites como &lt;strong&gt;Viber&lt;/strong&gt;, &lt;strong&gt;PayPal&lt;/strong&gt;, &lt;strong&gt;LinkedIn&lt;/strong&gt; e &lt;strong&gt;eBay&lt;/strong&gt;, servindo facilmente &lt;em&gt;terabytes&lt;/em&gt; e &lt;em&gt;petabytes&lt;/em&gt; de
dados.&lt;/p&gt;

&lt;p&gt;O Couchbase, assim como o &lt;strong&gt;MongoDB&lt;/strong&gt;, é famoso por ser potente pois tem grande escalabilidade entre máquinas, o que
é perfeito para startup e grandes companhias que precisam distribuir suas enormes
base de dados entre vários &lt;em&gt;cores&lt;/em&gt; garantindo desempenho para seus sistemas.&lt;/p&gt;

&lt;p&gt;O que difere os dois é que o MongoDB armazena dados em documentos &lt;code&gt;JSON&lt;/code&gt;. O Coubase
também tem um potente sistema de documentos armazenados em &lt;code&gt;JSON&lt;/code&gt; porém podemos dizer que ele
é híbrido pois também armazena dados em &lt;strong&gt;chave-valor&lt;/strong&gt; (&lt;em&gt;key/value&lt;/em&gt;). Diferente do MongoDB que tem
a capacidade de armazenar dados apenas em documentos, o que não é ideal para aplicações que
armazenam dados simples em quantidades extremas, como é o caso de um &lt;strong&gt;chat&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Armazenar dados em documentos pode causar armazenamento extra de &lt;em&gt;bytes&lt;/em&gt; que podemos
facilmente virar &lt;em&gt;petabytes&lt;/em&gt; de dados desnecessários para
um aplicativo que não precisa desse tipo de armazenamento. Para esses casos é preferível
utilizar armazenamento do tipo chave-valor.&lt;/p&gt;

&lt;h2 id=&quot;um-pouco-da-histria-do-couchbase&quot;&gt;Um pouco da História do Couchbase&lt;/h2&gt;

&lt;p&gt;Muito antes do termo &lt;strong&gt;NoSQL&lt;/strong&gt; os bancos de dados relacionais tinham a ajuda de uma tecnologia
chamada &lt;strong&gt;Memcached&lt;/strong&gt; para atenderem a demanda de escalabilidade de aplicações modernas. 
O Memcached, usado muito hoje em dia ainda, é um sistema de armazenamento distribuído de
chave-valor usado para camada de cache distribuído de aplicações.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores do Memcached viram uma grande oportunidade de entregar mais além de cache
e entregaram novas funcionalidades como protocolos binário, melhor gerenciamento de cluster,
e o mais importante: persistência.&lt;/p&gt;

&lt;p&gt;Esse novo produto ficou conhecido como &lt;strong&gt;Membase&lt;/strong&gt;. Uma tecnologia disruptiva que mudou o
jeito que aplicações armazenavam dados e que rapidamente ganhou popularidade entre os
desenvolvedores que precisavam de enorme escalabilidade.&lt;/p&gt;

&lt;p&gt;E então, paralelamente, no mundo do NoSQL, surgiu o &lt;strong&gt;CouchDB&lt;/strong&gt; que, assim como o MongoDB, armazena documentos
em &lt;code&gt;JSON&lt;/code&gt; e é potente e amigável.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;CouchDB&lt;/strong&gt; e o &lt;strong&gt;Membase&lt;/strong&gt; cresceram, ficaram maduros e os desenvolvedores dos dois
produtos se juntaram e criaram o &lt;strong&gt;Couchbase&lt;/strong&gt;. Um novo banco de dados criado do zero e otimizado
com as melhores tecnologias dos dois produtos anteriores.&lt;/p&gt;

&lt;p&gt;O resultado é um banco de dados NoSQL, open-source, com potente escalabilidade, extremamente
rápido, que nos dá a opção de armazenar dados em &lt;code&gt;JSON&lt;/code&gt; através de documentos e em chave/valor.
E ainda nos dá a possibilidade de escalar de maneira muito fácil entre vários &lt;em&gt;cores&lt;/em&gt; devido
ao seu passado com Memcached.&lt;/p&gt;

&lt;p&gt;Assim podemos usar suas características de chave/valor e escalabilidade para armazenar e
recuperar, por exemplo, o enorme número de mensagens que um aplicativo de &lt;em&gt;chat&lt;/em&gt; tem de maneira mais rápida
e usar sua característica de documentos para armazenar as informações de cada usuário por exemplo.&lt;/p&gt;

&lt;p&gt;O Couchbase ainda nos dá a possibilidade de sincronizarmos nossos dados locais e &lt;em&gt;online&lt;/em&gt;,
possibilitando que nosso app também funcione &lt;em&gt;offline&lt;/em&gt;, sincronizando os dados quando o usuário
fica &lt;em&gt;online&lt;/em&gt; de novo.&lt;/p&gt;

&lt;p&gt;O Couchbase pode ser baixado em &lt;a href=&quot;http://www.couchbase.com&quot;&gt;http://www.couchbase.com&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Apr 2017 19:38:20 -0300</pubDate>
        <link>http://blini.io/o-couchbase-e-suas-diferencas-do-mongo-db</link>
        <guid isPermaLink="true">http://blini.io/o-couchbase-e-suas-diferencas-do-mongo-db</guid>
        
        <category>Couchbase</category>
        
        <category>NoSQL</category>
        
        <category>MongoDB</category>
        
        <category>Databases</category>
        
        <category>Comparações</category>
        
        
        <category>Couchbase</category>
        
        <category>NoSQL</category>
        
        <category>MongoDB</category>
        
        <category>Databases</category>
        
      </item>
    
      <item>
        <title>Criando um Chat Realtime com CEAN Stack (Couchbase, Express, Angular2 e Node) e Socket.io - Parte 2 - Front-end</title>
        <description>&lt;p&gt;Esse artigo é a segunda parte do artigo anterior, quando criamos o &lt;em&gt;Back-end&lt;/em&gt;, configuramos
o &lt;strong&gt;Socket.io&lt;/strong&gt; no servidor e criamos um &lt;em&gt;Front-end&lt;/em&gt; bem simples usando nenhum &lt;em&gt;framework&lt;/em&gt; e
configuramos o &lt;strong&gt;Socket.io&lt;/strong&gt; no cliente através da biblioteca &lt;strong&gt;socket.io-client.js&lt;/strong&gt;.
Nesse artigo veremos como criar o mesmo &lt;em&gt;Front-end&lt;/em&gt; bem simples mas agora com &lt;strong&gt;Angular 2&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Existem diversas maneiras de inicializar um projeto em Angular 2, nesse artigo vamos usar
o &lt;a href=&quot;https://cli.angular.io/&quot;&gt;Angular CLI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O  Angular CLI deve ser instalado globalmente na sua máquina através do &lt;strong&gt;NPM&lt;/strong&gt; como é
mostrado no site oficial: &lt;a href=&quot;https://cli.angular.io/&quot;&gt;https://cli.angular.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install -g angular-cli&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Como já definimos e configuramos na &lt;a href=&quot;http://blini.io/criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-1&quot;&gt;primeira parte desse artigo&lt;/a&gt;
a pasta &lt;code&gt;public&lt;/code&gt; como o local onde nosso Front-end residirá, vamos abrir a pasta &lt;code&gt;public&lt;/code&gt;
no terminal e inicializar um novo projeto &lt;strong&gt;Angular&lt;/strong&gt; com ajuda do seu &lt;strong&gt;CLI&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Se você não acompanhou o artigo anterior, você pode acessar o código que criamos lá
&lt;a href=&quot;https://github.com/felipeblini/CEAN-Stack-and-Socket.io-chat-tutorial-part1&quot;&gt;neste repositório do GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Abra a pasta do projeto no terminal e navegue para a pasta &lt;code&gt;public&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ cd public&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Aqui vamos inicializar um novo projeto Angular 2. Para simplificar esse exemplo não vamos
gerar arquivos de teste e nem configurar o &lt;code&gt;git&lt;/code&gt;. Eu costumo pular o instalação dos pacotes
&lt;strong&gt;NPM&lt;/strong&gt; também pois eu prefiro usar o &lt;a href=&quot;https://yarn.com&quot;&gt;yarn&lt;/a&gt;.
Vamos também dar o nome de &lt;code&gt;cean-frontend&lt;/code&gt; para a nossa
aplicação Angular. O CLI do Angular nós dá 2 comandos para iniciar um novo projeto:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;ng init&lt;/code&gt;: cria um novo projeto na pasta atual.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ng new&lt;/code&gt;: cria uma nova pasta com o nome da aplicação e roda o &lt;code&gt;ng init&lt;/code&gt; dentro dela.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamos usar o &lt;code&gt;ng init&lt;/code&gt; já que não queremos que o Angular gere uma nova pasta para nós. Mas
antes de rodar esse comando precisamos renomear o arquivo &lt;code&gt;package.json&lt;/code&gt; que temos na raiz 
do projeto Express, pois o Angular CLI, antes de gerar o código, verifica a existência de 
qualquer arquivo &lt;code&gt;package.json&lt;/code&gt; na estrutura de pastas, e se caso houver ele usa este como 
sendo o seu arquivo de pacotes padrão, tenta sobrescrevê-lo e cria o projeto na mesma pasta dele.
Então, para contornar isso, vamos renomear temporariamente esse arquivo para &lt;code&gt;_package.json&lt;/code&gt;.
Outra coisa que devemos fazer é apagar o &lt;code&gt;html&lt;/code&gt; e o &lt;code&gt;js&lt;/code&gt; que criamos no artigo anterior dentro
da pasta &lt;code&gt;public&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A estrutura do projeto até agora está assim:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/cean-stack-structure.jpg&quot; alt=&quot;img cean-stack-structure.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A pasta &lt;code&gt;public&lt;/code&gt; está vazia e o &lt;code&gt;package.json&lt;/code&gt; renomeado. Agora sim podemos rodar o &lt;code&gt;ng-init&lt;/code&gt;
no terminal:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ ng init -n cean-frontend --skip-test --skip-git --skip-npm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso vai gerar todo o código inicial do Angular que precisamos. Pode excluir a pasta &lt;code&gt;e2e&lt;/code&gt;
e os arquivos &lt;code&gt;karma.conf.js&lt;/code&gt; e &lt;code&gt;protractor.conf.js&lt;/code&gt; já que não vamos trabalhar testes aqui.
Agora também devemos renomear de volta &lt;code&gt;package.json&lt;/code&gt; da raiz do nosso projeto,
retirando o &lt;em&gt;underline&lt;/em&gt; que colocamos anteriormente.&lt;/p&gt;

&lt;p&gt;Se você usou a &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;--skip-npm&lt;/code&gt; agora você deve instalar os pacotes, eu uso o &lt;code&gt;yarn&lt;/code&gt; para isso:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ yarn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;O yarn roda em cima do npm. Caso você não o tenha instalado na sua máquina você pode
instalá-lo globalmente através do próprio npm.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install -g yarn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se você prefere usar o NPM direto use &lt;code&gt;$ npm install&lt;/code&gt; ou não use a &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;--skip-npm&lt;/code&gt; no momento
do &lt;em&gt;scaffolding&lt;/em&gt; do projeto que o CLI instala todos os pacotes automaticamente.&lt;/p&gt;

&lt;p&gt;Com as dependências instaladas podemos rodar nosso front, também utilizando o CLI para isso,
na pasta &lt;code&gt;public&lt;/code&gt; rode o comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ ng serve -o&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso vai acionar o &lt;strong&gt;Webpack&lt;/strong&gt; que está embutido dentro do Angular CLI, que vai compilar
todo o código &lt;strong&gt;TypeScript&lt;/strong&gt; em &lt;strong&gt;ES5&lt;/strong&gt; e carregar todos os módulos que estão sendo
importados a partir do arquivo &lt;code&gt;main.ts&lt;/code&gt; por diante, vai minificar e agrupar todos os
arquivos em &lt;em&gt;bundles&lt;/em&gt; e os servir pra nós em memória no nosso ambiente de &lt;code&gt;dev&lt;/code&gt;. A &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;-o&lt;/code&gt;
faz com que o CLI abra o navegador com a aplicação rodando, e ainda qualquer alteralçao no
código será refetida no navegador sem a necessidade de dar um &lt;em&gt;refresh&lt;/em&gt;:&lt;/p&gt;

&lt;h4 id=&quot;app-works&quot;&gt;app works!&lt;/h4&gt;

&lt;p&gt;É claro que precisaremos de um processo de &lt;em&gt;build&lt;/em&gt; para produção, fique tranquilo(a),
vamos ver isso mais adiante.&lt;/p&gt;

&lt;p&gt;Agora com o front rodando vamos customizá-lo.&lt;/p&gt;

&lt;h2 id=&quot;componentes-em-angular&quot;&gt;Componentes em Angular&lt;/h2&gt;

&lt;p&gt;O Angular 2 é totalmente baseado em &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components&lt;/a&gt;.
Web Component é a &lt;strong&gt;“combinação”&lt;/strong&gt; de um &lt;strong&gt;template HTML&lt;/strong&gt; com um &lt;strong&gt;JS&lt;/strong&gt;
e &lt;strong&gt;opcionalmente&lt;/strong&gt; um ou mais &lt;strong&gt;estilos CSS&lt;/strong&gt; e que podem ser facilmente testados, usados
e reusados por toda a aplicação. No caso do Angular 2, os componentes são
escrito por default em &lt;strong&gt;TypeScript&lt;/strong&gt;, tendo a opção também de escrever em JavaScript puro.
Cada arquivo &lt;code&gt;.ts&lt;/code&gt; de um componente em Angular pode ter seu template e um estilo css definidos
inline através das propriedades &lt;code&gt;template&lt;/code&gt; e &lt;code&gt;style&lt;/code&gt; definidas no &lt;em&gt;decorator&lt;/em&gt; &lt;code&gt;@Componet&lt;/code&gt;
ou podem estar em arquivos separados referenciados nas propriedades &lt;code&gt;templateUrl&lt;/code&gt; e o &lt;em&gt;array&lt;/em&gt;
&lt;code&gt;styleUrls&lt;/code&gt;. Também é passado como propriedade o &lt;strong&gt;seletor html&lt;/strong&gt; desse
componente. E é assim que criamos um componente em Angular 2.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;boilerplate&lt;/em&gt; que o CLI nos gerou vem com o componente principal da aplicação, pois como já
dito anteriormente tudo é componente em Angular 2, inclusive a nossa aplicação também é um
componente, pai de todos os outros componentes e também tem o seu seletor. Se você abrir
o arquivo &lt;code&gt;app.component.ts&lt;/code&gt; vai ver que o seletor está definido como &lt;code&gt;app-root&lt;/code&gt;. E se você for
adiante e abrir o &lt;code&gt;index.html&lt;/code&gt; vai ver que o &lt;code&gt;app-root&lt;/code&gt; está sendo invocado lá, e é lá que
nossa aplicação inteira vai rodar.&lt;/p&gt;

&lt;p&gt;Vamos criar o component &lt;code&gt;Chat&lt;/code&gt; com ajuda do CLI. No terminal, pare o servidor com &lt;code&gt;ctrl + c&lt;/code&gt;
e ainda na pasta &lt;code&gt;public&lt;/code&gt;, use o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ ng generate component chat&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso vai criar um componente com o nome &lt;code&gt;Chat&lt;/code&gt; no lugar certo na estrutura da nossa aplicação e
seguindo a nomenclatura e convenção do Angular: dentro da pasta &lt;code&gt;app&lt;/code&gt; e dentro de uma pasta
nova chamada &lt;code&gt;chat&lt;/code&gt;. Como mostrado abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/chat-component.jpg&quot; alt=&quot;img chat-component.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Se você abrir o arquivo &lt;code&gt;chat.component.ts&lt;/code&gt; vai notar que o seletor desse component é &lt;code&gt;app-chat&lt;/code&gt;.
Então vamos abrir o template do nosso componente principal, &lt;code&gt;app.component.html&lt;/code&gt;, e
substituir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;h1&amp;gt;
  &amp;#123;&amp;#123;title}}
&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;app-chat&amp;gt;&amp;lt;/app-chat&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E em &lt;code&gt;chat.component.css&lt;/code&gt;, estilize o elemento &lt;code&gt;p&lt;/code&gt; do nosso novo componente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;p {
    font-size: 36px;
    font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rode o servidor denovo &lt;code&gt;$ ng server -o&lt;/code&gt; e se tudo estiver certo você vai ver no navegador
o texto:&lt;/p&gt;

&lt;h4 id=&quot;chat-works&quot;&gt;chat works!&lt;/h4&gt;

&lt;p&gt;Pronto, nosso componente filho está sendo renderizado na tela. Agora vamos customizá-lo
e deixá-lo com a mesma cara do &lt;em&gt;Front-end&lt;/em&gt; anterior.&lt;/p&gt;

&lt;h2 id=&quot;customizando-o-componente&quot;&gt;Customizando o Componente&lt;/h2&gt;

&lt;p&gt;Em &lt;code&gt;app.component.html&lt;/code&gt; substitua o código por:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;ul id=&quot;messages&quot;&amp;gt;
    &amp;lt;li *ngFor=&quot;let msg of messages&quot;&amp;gt;&amp;#123;&amp;#123; msg }}&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;form action=&quot;&quot;&amp;gt;
    &amp;lt;input [(ngModel)]=&quot;chatBox&quot; name=&quot;chatBox&quot; autocomplete=&quot;off&quot; /&amp;gt;
    &amp;lt;button (click)=&quot;send()&quot;&amp;gt;Enviar&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que está sendo feito no código acima é a criação de uma lista &lt;code&gt;ul&lt;/code&gt; de mensagens sendo que o 
&lt;code&gt;li&lt;/code&gt; está sendo repetido para cada mensagem dentro do &lt;em&gt;array&lt;/em&gt; chamado &lt;code&gt;messages&lt;/code&gt; que será
definido e populado no JavaScript deste componente, criando assim o &lt;em&gt;data binding&lt;/em&gt; entre o template
e o código JavaScript. Utilizamos a diretiva *ngFor do Angular 2 para fazer essa “cola” (bind)
e percorrer o &lt;em&gt;array&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O segundo elemento html é um formulário com um &lt;code&gt;input&lt;/code&gt; do tipo texto chamado &lt;code&gt;chatBox&lt;/code&gt; também
“colado” ao JavaScript através do &lt;code&gt;ngModel&lt;/code&gt;. Esta “cola” é do tipo &lt;em&gt;two-way-databind&lt;/em&gt;
pois englobamos o &lt;code&gt;ngModel&lt;/code&gt; entre colchetes e parênteses &lt;code&gt;[()]&lt;/code&gt;, assim toda vez que o valor
dessa propriedade mudar, em qualquer lugar, será refletido tanto no HTML quanto no JS.&lt;/p&gt;

&lt;p&gt;Também criamos um botão “Enviar” com o seu evento &lt;code&gt;click&lt;/code&gt; “colado” a um manipulador chamado
&lt;code&gt;send&lt;/code&gt; que é uma função que recebe o valor atual do &lt;code&gt;input&lt;/code&gt; &lt;code&gt;chatBox&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Em &lt;code&gt;app.component.css&lt;/code&gt;, estilize nosso componente da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#messages,* { margin:0;padding:0 }
* { box-sizing:border-box }
body { font:13px Helvetica, Arial }
form { background:#000; padding:3px; position:fixed; bottom:0; width:100% }
form input { border:0; padding:10px; width:90%; margin-right:.5% }
form button{ width:9%; background:#82e0ff; border:none; padding:10px } 
#messages { list-style-type:none }
#messages li { padding:5px 10px}
#messages li:nth-child(odd) { background:#eee }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Estes html e css foram retirados da &lt;a href=&quot;http://socket.io/docs/&quot;&gt;documentação do Socket.io&lt;/a&gt; e
adaptados para esse artigo.&lt;/p&gt;

&lt;p&gt;As diretivas de formulário do Angular (&lt;code&gt;ngModel&lt;/code&gt;, &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;*ngFor&lt;/code&gt;, etc) usadas acima
dependem de &lt;strong&gt;módulos do Angular&lt;/strong&gt; que devem ser importados no módulo pai do componente
que os está usando. O módulo pai do nosso componente é o módulo principal da aplicação - a
classe &lt;code&gt;AppModule&lt;/code&gt; - definida em &lt;code&gt;app.module.ts&lt;/code&gt;.
O comando do CLI usado para gerar o componente já faz essa importação
para a gente. Se você abrir o arquivo &lt;code&gt;app.module.ts&lt;/code&gt; vai ver que o &lt;strong&gt;ChatComponent&lt;/strong&gt;
está sendo importado lá e inserido no &lt;em&gt;array&lt;/em&gt; &lt;strong&gt;declarations&lt;/strong&gt; assim como o módulo
&lt;strong&gt;FormsModule&lt;/strong&gt;, responsável pelas direticas em questão, também está sendo importado e
declarado em &lt;code&gt;imports&lt;/code&gt;. O &lt;strong&gt;HttpModule&lt;/strong&gt; também está presente, vamos usá-lo mais pra frente.&lt;/p&gt;

&lt;p&gt;No nosso template o botão “Enviar” invoca uma função chamada &lt;code&gt;send&lt;/code&gt; e a nossa lista &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;
repete um &lt;em&gt;array&lt;/em&gt; chamado &lt;code&gt;messages&lt;/code&gt;. Bora alterar a classe do nosso componente para atender
esses requisitos então. Abra o arquivo &lt;code&gt;chat.component.ts&lt;/code&gt; e deixe-o assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Component, OnInit } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-chat&#39;,
  templateUrl: &#39;./chat.component.html&#39;,
  styleUrls: [&#39;./chat.component.css&#39;]
})
export class ChatComponent implements OnInit {

  // propriedades do view model
  messages: Array&amp;lt;String&amp;gt;;
  chatBox: String;

  constructor() {
    // valores iniciais para as propriedades
    this.messages = [];
    this.chatBox = &quot;&quot;;
  }

  // function send()
  send() {
    if(!this.chatBox)
      return;
      
    console.log(&#39;sending message:&#39;, this.chatBox);
    this.messages.push(this.chatBox);
    this.chatBox = &quot;&quot;;
  }

  ngOnInit() {
    console.log(&#39;chat.component initialized&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima primeiro &lt;strong&gt;criamos as propriedades&lt;/strong&gt; &lt;code&gt;messages&lt;/code&gt; do tipo &lt;em&gt;array&lt;/em&gt; de &lt;code&gt;Strings&lt;/code&gt; e a
&lt;code&gt;chatBox&lt;/code&gt; do tipo &lt;code&gt;String&lt;/code&gt;. Atribuímos &lt;strong&gt;valores iniciais&lt;/strong&gt; a elas no Construtor da classe e
criamos o método &lt;code&gt;send&lt;/code&gt; que checa se a propriedade &lt;code&gt;chatBox&lt;/code&gt; tem um valor, se esta condição
for verdadeira, &lt;strong&gt;inclui o valor no array&lt;/strong&gt; &lt;code&gt;messages&lt;/code&gt;, e a propriedade &lt;code&gt;chatBox&lt;/code&gt; é
&lt;strong&gt;reinicializada com um valor vazio&lt;/strong&gt;. Como o array &lt;code&gt;messages&lt;/code&gt; está vinculado ao elemento
&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; do template através do &lt;code&gt;*ng-for&lt;/code&gt; e a propriedade &lt;code&gt;chatBox&lt;/code&gt; vinculada ao &lt;code&gt;input&lt;/code&gt; no
template através do &lt;code&gt;ngModel&lt;/code&gt;, &lt;strong&gt;essas mudanças se refletirão na tela&lt;/strong&gt; e tudo funcionará
como esperado.&lt;/p&gt;

&lt;p&gt;Se você abrir o &lt;em&gt;Front-end&lt;/em&gt; agora, tudo deverá estar funcionando, porém agora em Angular 2.
Digite um texto no campo e clique no botão “Enviar”. As mensagens enviadas irão aparecer
na tela uma após a outra com cores de linha alternadas.&lt;/p&gt;

&lt;p&gt;Agora precisamo fazer a parte do Socket.io funcionar como antes, como pode ser visto
&lt;a href=&quot;criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-1#funcionar-como-antes&quot;&gt;
no final do último post&lt;/a&gt;, para sermos capazes de enviar e receber mensagens de e para outros &lt;em&gt;sockets&lt;/em&gt;
conectados, só que agora no Angular 2 também.&lt;/p&gt;

&lt;h2 id=&quot;criando-um-cliente-do-socketio-no-angular-2&quot;&gt;Criando um cliente do Socket.io no Angular 2&lt;/h2&gt;

&lt;p&gt;Nosso front-end tá quase pronto, agora precisamos usar o Socket.io no método &lt;code&gt;send&lt;/code&gt; para enviar a mensagem
em &lt;em&gt;broadcast&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Então pra finalizar nosso Front-end vamos instalar e configurar o &lt;strong&gt;&lt;em&gt;client&lt;/em&gt; do Socket.io&lt;/strong&gt;
nos moldes do Angular 2.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;socket.io-client&lt;/code&gt; é uma biblioteca e também está disponível como um módulo no repositório
do npm.&lt;/p&gt;

&lt;p&gt;Se você abrir a pasta &lt;code&gt;node_modules&lt;/code&gt; dentro da pasta &lt;code&gt;public&lt;/code&gt; vai encontrar a pasta &lt;strong&gt;socket.io-client&lt;/strong&gt;,
isso significa que ele já está instalado, pois ele &lt;strong&gt;já vem no projeto criado pelo CLI&lt;/strong&gt;.
Caso não encontre basta instalá-lo através do npm:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install --save socket.io-client&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para utilizarmos essa biblioteca precisamos importá-la em nosso código.&lt;/p&gt;

&lt;p&gt;Abra novamente o arquivo &lt;code&gt;chat.component.ts&lt;/code&gt; e inclua a seguinte linha após o &lt;code&gt;@angular/core&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import * as io from &#39;socket.io-client&#39;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isso vai &lt;strong&gt;importar todos os métodos e propriedades públicas do módulo&lt;/strong&gt;
&lt;code&gt;socket.io-client&lt;/code&gt; dentro de uma variável chamada &lt;code&gt;io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se você rodar o &lt;code&gt;Front-end&lt;/code&gt; agora vai deparar com o erro:
*&lt;em&gt;Cannot find module ‘socket.io-client’&lt;/em&gt;**.&lt;/p&gt;

&lt;p&gt;Isso acontece pois o Angular, através do &lt;strong&gt;Webpack&lt;/strong&gt;, importa módulos em &lt;strong&gt;TypeScript&lt;/strong&gt;. No TypeScript nós
temos tipos estático, no &lt;strong&gt;JavaScript&lt;/strong&gt; puro não. O socket.io-client é uma biblioteca escrita
em JavaScript puro, então o &lt;strong&gt;Webpack&lt;/strong&gt;, que compila e carrega os módulos TypeScript para o
Angular, não consegue fazer seu trabalho pois não encontra nenhum módulo &lt;code&gt;.ts&lt;/code&gt; com o nome
&lt;em&gt;socket.io-client&lt;/em&gt; e então nenhum módulo com esse nome é encontrado.&lt;/p&gt;

&lt;p&gt;Para resolver isso precisamos definir tipos para a biblioteca que queremos usar criando
um arquivo &lt;code&gt;.ts&lt;/code&gt; para ela. Se você abrir o arquivo de configuração do TypeScript,
&lt;code&gt;tsconfig.json&lt;/code&gt; vai ver a propriedade &lt;code&gt;typeRoots&lt;/code&gt; apontando para &lt;code&gt;../node_modules/@types&lt;/code&gt;.
É alí que o compilador do TypeScript vai procurar por tipos para bibliotecas importadas
em JavaScripts. Poderíamos criar um novo diretório alí com o nome &lt;strong&gt;socket.io-client&lt;/strong&gt; e
um arquivo &lt;code&gt;index.d.ts&lt;/code&gt; definindo e exportando esses tipos e o TypeScript saberia o que
compilar. Porém para nos ajudar com isso existe o repositório online &lt;strong&gt;Typings&lt;/strong&gt; com essas
definições de tipos para diversas bibliotecas que não são escritas em TypeScript.&lt;/p&gt;

&lt;p&gt;Se caso a biblioteca que você precisa não possuir um &lt;em&gt;typing&lt;/em&gt; disponível, basta criar um bem
simples em uma pasta com o mesmo nome da biblioteca e um arquivo &lt;code&gt;index.d.ts&lt;/code&gt; dentro
&lt;em&gt;fakeando&lt;/em&gt; isso.&lt;/p&gt;

&lt;p&gt;O socket.io-client possui um &lt;em&gt;typing&lt;/em&gt;, então vamos instalá-lo. Na pasta public rode o comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install --save-dev @types/socket.io-client&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Usamos &lt;code&gt;--save-dev&lt;/code&gt; pois precisamos de Typings apenas no ambiente de desenvolvimento, &lt;strong&gt;nenhum
arquivo de Typings e TypeScript vai para produção&lt;/strong&gt;, apenas JavaScript, assim não precisamos de Typings
em produção.&lt;/p&gt;

&lt;p&gt;Feito isso você pode verificar a instalação.&lt;/p&gt;

&lt;p&gt;Abrindo a pasta &lt;code&gt;node_module/@types&lt;/code&gt; você verá a
pasta &lt;code&gt;socket.io-client&lt;/code&gt; com o arquivo &lt;code&gt;index.d.ts&lt;/code&gt; exportando o módulo com todos os tipos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/socket.io-client@types.jpg&quot; alt=&quot;img socket.io-client@types.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Se você rodar o front novamente verá que o erro sumiu.&lt;/p&gt;

&lt;p&gt;Muito bem, agora vamos alterar nosso componente para que cada vez que o método &lt;code&gt;send()&lt;/code&gt;
for invocado ele emita o evento &lt;code&gt;mensagem_mano&lt;/code&gt; junto com o valor da propriedade &lt;code&gt;chatBox&lt;/code&gt;
para todos os sockets conectados.&lt;/p&gt;

&lt;p&gt;Na classe do componente &lt;strong&gt;Chat&lt;/strong&gt; (&lt;code&gt;chat.component.ts&lt;/code&gt;) faça isso:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { Component, OnInit } from &#39;@angular/core&#39;;
import * as io from &#39;socket.io-client&#39;;

@Component({
  selector: &#39;app-chat&#39;,
  templateUrl: &#39;./chat.component.html&#39;,
  styleUrls: [&#39;./chat.component.css&#39;]
})
export class ChatComponent implements OnInit {

  // propriedades do view model
  messages: Array&amp;lt;String&amp;gt;;
  chatBox: String;

  // -----&amp;gt; nova propriedade
  socket: any; // &amp;lt;-------------

  constructor() {
    // valores iniciais para as propriedades
    this.messages = [];
    this.chatBox = &quot;&quot;;

    // ------&amp;gt; Instanciando o Socket.io
    this.socket = io();

    // Sempre que o servidor emitir o evento &#39;mensagem_mano&#39;, o socket do
    // usuário conectado vai capturar esse evento e executar a função callback
    // que adiciona o valor recebido no array de messages
    this.socket.on(&quot;mensagem_mano&quot;, (msg: string) =&amp;gt; {
      console.log(&#39;receiving message:&#39;, msg)
      this.messages.push(msg);
    }); // &amp;lt;-----------------
  }

  // function send()
  send() {
    if(!this.chatBox)
      return;

    console.log(&#39;sending message:&#39;, this.chatBox);
    
    // -------&amp;gt; pede ao servidor para executar o evento &#39;mensagem_mano&#39;
    // e transmitir 1 parâmetro que vai para todos os usuários
    // conectados, inclusive para quem enviou
    this.socket.emit(&quot;mensagem_mano&quot;, this.chatBox); // &amp;lt;------------

    this.chatBox = &quot;&quot;;
  }

  ngOnInit() {
    console.log(&#39;chat.component initialized&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS: os novos blocos de código incluídos estão entre &lt;code&gt;// -------&amp;gt;&lt;/code&gt; e  &lt;code&gt;// &amp;lt;------------&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Primeiro criamos uma &lt;strong&gt;nova propriedade do tipo&lt;/strong&gt; &lt;code&gt;any&lt;/code&gt; &lt;strong&gt;chamada&lt;/strong&gt; &lt;code&gt;socket&lt;/code&gt; e no construtor da
classe &lt;strong&gt;definimos esta propriedade como uma instância de socket.io-client&lt;/strong&gt; que importamos
anteriormente dentro da variável &lt;code&gt;io&lt;/code&gt;. Ainda no construtor da classe &lt;strong&gt;definimos um ouvinte
para o evento&lt;/strong&gt; &lt;code&gt;mensagem_mano&lt;/code&gt; que irá capturar todas mensagens transmitidas pelo evento emitido
por qualquer socket, inclusive as mensagens do próprio usuário que a enviou, do mesmo jeito
que fizemos no último código da parte 1 desse artigo. E na função &lt;code&gt;send()&lt;/code&gt; ao invés de jogarmos
o valor do &lt;code&gt;chatBox&lt;/code&gt; para dentro do array vamos passá-la pra frente e deixar a cargo dos
ouvintes de todos os sockets adicioná-lo ao array.&lt;/p&gt;

&lt;p&gt;Para testarmos precisamos do Back-end e do Front-end rodando. O servidor Back-end está
configurado no &lt;strong&gt;Express&lt;/strong&gt; para rodar na porta &lt;code&gt;3000&lt;/code&gt; e o Angular está rodando “virtualmente”
na porta &lt;code&gt;4200&lt;/code&gt;. “Virtualmente” pois o código JavaScript é servido em memória e não fisicamente.&lt;/p&gt;

&lt;p&gt;Precisamos gerar fisicamente os arquivos do Angular em &lt;em&gt;bundles&lt;/em&gt; e serví-los também na porta
&lt;code&gt;3000&lt;/code&gt; como arquivos estáticos através do &lt;strong&gt;Express&lt;/strong&gt;. Rodando assim &lt;strong&gt;tanto o Back-end quanto o
Front-end na mesma porta&lt;/strong&gt;, o que é um requisito para esse exemplo em específico funcionar.&lt;/p&gt;

&lt;p&gt;Para isso precisamos que o nosso Front-end passe por um &lt;strong&gt;processo de build para produção&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;fazendo-o-build-do-angular-para-produo&quot;&gt;Fazendo o Build do Angular para Produção&lt;/h3&gt;

&lt;p&gt;O &lt;strong&gt;Webpack&lt;/strong&gt; é o cara responsável por fazer esse processo.&lt;/p&gt;

&lt;p&gt;Se você abrir o arquivo &lt;code&gt;angular-cli.json&lt;/code&gt; vai perceber que já existe um processo de
build configurado que será usado pelo Webpack. Analizando a propriedade &lt;code&gt;apps&lt;/code&gt; desse arquivo temos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&quot;root&quot;: &quot;src&quot;&lt;/code&gt;: onde os arquivos de desenvolvimento estão&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&quot;outDir&quot;: &quot;dist&lt;/code&gt;”: em qual pasta os arquivos compilados e prontos para a produção serão gerados&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&quot;index&quot;: &quot;index.html&lt;/code&gt;: em qual arquivo html os &lt;em&gt;bundles&lt;/em&gt; com os códigos compilados devem ser injetados&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&quot;main&quot;: &quot;main.ts&quot;&lt;/code&gt;: a partir de qual arquivo o processo de carregamento de módulos e compilação deve iniciar&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Com essas 4 informações já temos uma idéia de o que o Webpack vai fazer. E para realizar
esse processo de build utilizamos novamente o &lt;strong&gt;CLI do Angular&lt;/strong&gt; com o comando &lt;code&gt;ng build&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então no terminal, dentro da pasta &lt;code&gt;public&lt;/code&gt; rodamos o comando com a &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;-p&lt;/code&gt; informando
que estamos fazendo um build para produção:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ ng build -p&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;rodando-a-aplicao&quot;&gt;Rodando a Aplicação&lt;/h3&gt;

&lt;p&gt;Com o &lt;em&gt;build&lt;/em&gt; finalizado você verá que foram gerados vários &lt;em&gt;bundles&lt;/em&gt; para nossos códigos
(&lt;strong&gt;componentes&lt;/strong&gt;), para os &lt;em&gt;vendors&lt;/em&gt; (&lt;strong&gt;Angular&lt;/strong&gt; e &lt;strong&gt;socket.io-client&lt;/strong&gt;) e para os estilos &lt;code&gt;css&lt;/code&gt;.
E que esses arquivos todos foram gerados dentro de um &lt;strong&gt;nova pasta chamada&lt;/strong&gt; &lt;code&gt;dist&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;É essa pasta que devemos servir com estática dentro de nossa &lt;em&gt;stack&lt;/em&gt;. Então no arquivo &lt;code&gt;app.js&lt;/code&gt;
onde configuramos o &lt;strong&gt;Express&lt;/strong&gt;, vamos configurar iss como já havíamos
feito para a pasta &lt;code&gt;public&lt;/code&gt; colocando &lt;code&gt;/dist&lt;/code&gt; na frente&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;app.use(express.static(path.join(__dirname, &quot;public&quot;, &quot;dist&quot;)));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora com a pasta configurada, no terminal navegue até a raiz do projeto e rode o servidor
Express:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ node app&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;E acesse &lt;code&gt;http://localhost:3000/&lt;/code&gt; em vários navegadores ou abas e envie mensagens de chat
entre eles!&lt;/p&gt;

&lt;p&gt;No artigo anterior nós configuramos um &lt;em&gt;end-point&lt;/em&gt; no nosso Back-end que nos retorna o
histórico de mensagens do chat, se você acessar &lt;code&gt;http://localhost:3000/mensagens&lt;/code&gt; vai ver
que também está funcionando. É nesse &lt;em&gt;end-point&lt;/em&gt; que vamos integrar nossa aplicação com o
&lt;strong&gt;CouchBase&lt;/strong&gt; no próximo artigo!&lt;/p&gt;

&lt;p&gt;Aí você me pergunta: porquê raios o &lt;strong&gt;Couchbase&lt;/strong&gt; e não &lt;strong&gt;MongoDB&lt;/strong&gt;? Porquê usar &lt;strong&gt;CEAN&lt;/strong&gt; e não &lt;strong&gt;MEAN&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Eu preparei uma pequeno texto respondendo isso: &lt;a href=&quot;/o-couchbase-e-suas-diferencas-do-mongo-db&quot;&gt;O Couchbase e suas Diferenças do MongoDB&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O código fonte dessa parte está &lt;a href=&quot;https://github.com/felipeblini/CEAN-Stack-and-Socket.io-chat-tutorial/tree/part-2&quot;&gt;neste repositório do Github&lt;/a&gt;
dentro da branch &lt;code&gt;part-2&lt;/code&gt;. Confere lá!&lt;/p&gt;

&lt;p&gt;Deixe o seu comentário, dúvidas e etc… Nos vemos no próximo artigo!&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Feb 2017 16:18:25 -0300</pubDate>
        <link>http://blini.io/criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-2</link>
        <guid isPermaLink="true">http://blini.io/criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-2</guid>
        
        <category>Socket.io</category>
        
        <category>Websockets</category>
        
        <category>Couchbase</category>
        
        <category>Node</category>
        
        <category>Express</category>
        
        <category>Angular</category>
        
        <category>JavaScript</category>
        
        
        <category>Socket.io</category>
        
        <category>Websockets</category>
        
        <category>Couchbase</category>
        
        <category>Node</category>
        
        <category>Express</category>
        
        <category>Angular</category>
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Criando um Chat Realtime com CEAN Stack (Couchbase, Express, Angular2 e Node) e Socket.io - Parte 1 - Back-end</title>
        <description>&lt;p&gt;Construir um chat há alguns anos costumava ser algo muito difícil de se fazer. Exigia-nos
construir uma arquitetura complexa. Tínhamos que consultar o servidor a todo momento
em busca de novas mensagens e isso era pouco performático. Como não tínhamos
bancos NoSql usávamos bancos de dados relacionais para persistir mensagens.
Era bastante trabalhoso e o resultado final muitas vezes era péssimo. Não era
qualquer um que encarava esse desafio. Hoje temos tecnologias que facilitam muito nossa
vida. Nesse tutorial/artigo vou mostrar como criar um chat &lt;em&gt;real-time&lt;/em&gt; de maneira muito
simples com Couchbase, Node.js, Express e Angular 2 (CEAN Stack ou CANE Stack) e Socket.io.&lt;/p&gt;

&lt;h1 id=&quot;construindo-o-backend&quot;&gt;Construindo o Backend&lt;/h1&gt;

&lt;p&gt;Primeiro vamos construir o backend. Uma &lt;strong&gt;API em Node.js&lt;/strong&gt; com um endpoint que vai nos
retornar todas as mensagens que estão no banco. Mas por enquanto essas mensagens serão &lt;em&gt;fakes&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Assumindo que você já tenha o Node instalado na sua máquina, crie uma nova pasta, abra-a
no Terminal/Prompt de Comando e &lt;strong&gt;inicie um novo projeto Node&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ echo {} &amp;gt; package.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso vai criar o arquivo &lt;code&gt;package.json&lt;/code&gt; com um objeto &lt;code&gt;JSON&lt;/code&gt; vazio onde as depêndencias do
projeto serão registradas. Não vamos usar o &lt;code&gt;npm init&lt;/code&gt; aqui pois ele gera campos que não
precisaremos nesse projeto.&lt;/p&gt;

&lt;p&gt;Vamos passar por um conteúdo bem básico, que é especificamente &lt;strong&gt;instalar o Express&lt;/strong&gt;
e &lt;strong&gt;subir o servidor Node&lt;/strong&gt;. Caso você já se sinta confortável em como se faz isso pode
pular para a &lt;a href=&quot;#criando-a-rota&quot;&gt;seção onde criamos a rota.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Siga em frente e instale a primeira dependência: o &lt;strong&gt;Express&lt;/strong&gt;, o framework que nos ajuda a
criar Middlewares e configurar o servidor Node.
Coloque a &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;--save&lt;/code&gt; no final pra registrar isso no &lt;code&gt;package.json&lt;/code&gt; como uma dependência de
produção.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install --save express&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Agora sim, podemos abrir a pasta em um editor de texto e começar a codar e criar
mais um app lindo que mudará o mundo para sempre. #SQN é apenas mais um chat mesmo!&lt;/p&gt;

&lt;p&gt;Eu gosto de usar o &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt;, então ainda no terminal eu
digito &lt;code&gt;$ code .&lt;/code&gt; e ele abre pra mim este editor de texto com a minha pasta aberta.
Se caso você usa o &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime&lt;/a&gt; você pode
tentar digitar &lt;code&gt;$ subl .&lt;/code&gt; se ele não abrir sinto muito mas você vai ter que 
&lt;a href=&quot;http://bfy.tw/9dMx&quot;&gt;configurar a variável de ambiente para o Sublime&lt;/a&gt; para abrir-lo pelo
terminal. Você pode usar qualquer editor de texto de sua preferência.&lt;/p&gt;

&lt;p&gt;Com a pasta aberta no editor de texto, você vai ver que temos a pasta &lt;code&gt;node_modules&lt;/code&gt;
e no arquivo &lt;code&gt;package.json&lt;/code&gt; o Express registrado na propriedade &lt;code&gt;dependencies&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;dependencies&quot;: {
    &quot;express&quot;: &quot;4.14.0&quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bora começar a mudar o mundo então, crie o arquivo &lt;code&gt;app.js&lt;/code&gt; que carregará a nossa API e
onde vamos configurar o nosso servidor com ajuda do Express. Para isso precisamos
&lt;strong&gt;importar o módulo Express&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando o módulo do express
const express = require(&#39;express&#39;);

// criando uma instância do express
const app = express();

// criando o servidor http para a nossa app
const server = require(&quot;http&quot;).Server(app);

// disponibilizando o app  na porta 3000 do servidor
server.listen(3000, () =&amp;gt;
    console.log(&quot;Listening on port %s...&quot;, server.address().port));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima nós &lt;strong&gt;importamos o express&lt;/strong&gt;, criamos uma &lt;strong&gt;instância dele dentro de uma
constante&lt;/strong&gt; chamada &lt;code&gt;app&lt;/code&gt;, &lt;strong&gt;criamos um servidor HTTP&lt;/strong&gt; para a nossa app e mandamos ele
&lt;strong&gt;ouvir requisições na porta 3000&lt;/strong&gt; subindo assim o servidor HTTP.&lt;/p&gt;

&lt;p&gt;Usar &lt;code&gt;const&lt;/code&gt; ao invés de &lt;code&gt;var&lt;/code&gt; aqui é
uma boa prática porque tanto o módulo quanto a instância do Express e o função
&lt;code&gt;Server()&lt;/code&gt; do módulo &lt;code&gt;http&lt;/code&gt; nunca vão mudar durante toda a
nossa aplicação. O valor deles será o mesmo durante todo o ciclo de vida da aplicação 
assim como a maioria dos módulos que importamos.&lt;/p&gt;

&lt;p&gt;Já temos um servidor rodando. Para verificar basta executar o nosso Javascript 
&lt;code&gt;app.js&lt;/code&gt; com o Node.&lt;/p&gt;

&lt;p&gt;No terminal digite &lt;code&gt;$ node app&lt;/code&gt; (não precisa colocar .js):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/node-listening.jpg&quot; alt=&quot;Node.js rodando&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Se você abrir no navegador em &lt;code&gt;http://localhost:3000&lt;/code&gt; você vai ver que funcionou, porém
vimos uma mensagem que não é possível achar a rota &lt;code&gt;/&lt;/code&gt; (Cannot GET /). Precisamos criar
uma rota para a nossa API.&lt;a id=&quot;criando-a-rota&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;criando-a-rota&quot;&gt;Criando a rota&lt;/h1&gt;

&lt;p&gt;A idéia é ter uma endpoint que irá retornar todas as mensagens do chat.
Como vamos construir o front-end e a API no mesmo aplicativo, rodando na mesma porta, vamos
deixar a rota padrão &lt;code&gt;/&lt;/code&gt; para o front-end (a sala de chat) que vamos criar mais pra frente,
e a rota &lt;code&gt;/mensagens&lt;/code&gt; para o endpoint da API que vai nos retornar todas as mensagens do chat.&lt;/p&gt;

&lt;p&gt;Para isso crie a pasta &lt;code&gt;routes&lt;/code&gt; na raiz do projeto.&lt;/p&gt;

&lt;p&gt;Na pasta &lt;code&gt;routes&lt;/code&gt; crie o arquivo &lt;code&gt;routes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = function (app) {
    app.get(&#39;/mensagens&#39;, (req, res) =&amp;gt; {
        res.send({mensagem: &#39;oi&#39;});
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora precisamos informar ao Express que temos uma rota configurada, fazemos isso
&lt;strong&gt;importando o código acima dentro do código onde configuramos o nosso servidor&lt;/strong&gt;,
no arquivo &lt;code&gt;app.js&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Perceba que a função acima, exportada com &lt;code&gt;module.exports&lt;/code&gt;, depende de um parâmetro que
nomeamos de &lt;code&gt;app&lt;/code&gt;, neste parâmetro deve conter a instância do Express que criamos. Porquê?
Porque o método &lt;code&gt;.get&lt;/code&gt; pertence à instância do Express. Esse método cria um Middleware que
avalia, em toda requisção, o recurso que foi solicitado pelo navegador e, nesse caso
específico, se o recurso for igual
a &lt;code&gt;/mensagens&lt;/code&gt; ele executa a arrow function que definimos como callback passando os objetos
de requisição (&lt;code&gt;req&lt;/code&gt;) e resposta (&lt;code&gt;res&lt;/code&gt;) permitindo-nos manipular a requisição feita
pelo usuário e a resposta que vamos enviar pra ele, esse é um conceito bem básico de
Middlewares.&lt;/p&gt;

&lt;p&gt;Beleza, chega de conceito e vamos importr nossa rota recém criada no servidor, abra o
arquivo &lt;code&gt;app.js&lt;/code&gt; e antes de subir o servidor (função &lt;code&gt;listen()&lt;/code&gt;) vamos informar a ele
que nós temos uma rota para um recurso, bora então importar o código da rota. Anova linha 
no arquivo &lt;code&gt;app.js&lt;/code&gt; está destacada com flechas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando o módulo express
const express = require(&#39;express&#39;);

// criando uma instância do express
const app = express();

// criando o servidor http para a nossa app
const server = require(&quot;http&quot;).Server(app);

// ----&amp;gt; importando nosso arquivo de rotas
const routes = require(&quot;./routes/routes.js&quot;); // &amp;lt;-----

server.listen(3000, () =&amp;gt;
    console.log(&quot;Listening on port %s...&quot;, server.address().port));
 &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se você executar o código e abrir o navegador vai ver que não vai funcionar, isso porque
no código acima nós apenas importamos a função. Nenhum Middleware foi e registrado
no servidor. Para registrá-lo precisamos executar a função imediatamente após a importarmos.
Fazemos isso, em JavaScript, colocando parênteses no final da chamada da função.
Além disso, para registrar o Middleware nossa módulo de rotas precisa da nossa instância
do Express. Nós temos essa instância dentro da constante app, então é só passar ela por
parâmetro que o nosso módulo de rotas se encarregará de registrar o middleware,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando nosso arquivo de rotas e executando-o imediatamente 
// depois com a instância do Express sendo passada por parâmetro
const routes = require(&quot;./routes/routes.js&quot;)(app);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora sim, executando o código no console (&lt;code&gt;$ node app&lt;/code&gt;) e abrindo o navegador na url 
&lt;code&gt;http://localhost:3000/mensagens&lt;/code&gt; você vai ver a mensagem retornada pelo nosso backend.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/message-oi.jpg&quot; alt=&quot;Express route, Node.js rodando&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Quando formos integrar nosso chat com o &lt;strong&gt;Couchbase&lt;/strong&gt; precisaremos escrever um pouco mais
de código criando funções para persistir e recuperar mensagens. Precisamos de um cara
responsável por isso, e esse cara é o modelo!&lt;/p&gt;

&lt;h1 id=&quot;criando-o-modelo&quot;&gt;Criando o modelo&lt;/h1&gt;

&lt;p&gt;A idéia inicial aqui é passar a lógica definida no arquivo de rota para um &lt;strong&gt;Model&lt;/strong&gt; e
depois, quando formos integrar com o &lt;strong&gt;Couchbase&lt;/strong&gt;, escrevermos mais funcionalidades.&lt;/p&gt;

&lt;p&gt;Para isso, crie uma pasta &lt;code&gt;models&lt;/code&gt; na raíz do projeto e dentro dela crie o arquivo
&lt;code&gt;chatmodel.js&lt;/code&gt; definindo uma função construtora nomeada &lt;strong&gt;ChatModel&lt;/strong&gt; (com C maiúsculo,
por convenção):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function ChatModel() {}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No artigo &lt;a href=&quot;http://blini.io/classes-e-objetos-em-javascript&quot;&gt;Classes e Objetos em Javascript&lt;/a&gt;
eu explico &lt;del&gt;tudo&lt;/del&gt; bastante coisa sobre funções construtoras&lt;/p&gt;

&lt;p&gt;Vamos criar o primeiro método do nosso modelo e definir que esse método espera um função
de callback que será executada assim que os dados estiverem prontos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function ChatModel() {}

ChatModel.getAll = function(callback) {
    let error = null;
    let result = {message: &#39;oi&#39;};
    callback(result, error);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os dados serão enviados à função de callback por parâmetro (última linha dentro da função) e se ocorrer
algum erro será enviado um objeto de erro no segundo parâmetro. Usamos esse padrão pois
no Node consultas de dados são assíncronas e não bloqueantes, isso quer dizer que o
Express não vai esperar os dados ficarem prontos, ele vai prosseguir com o processamento
e só depois que os dados chegarem do banco ele vai disponibilizar isso para o &lt;em&gt;callback&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perceba que ainda não estamos consultando dados, apenas retornando a mesma mensagem de antes.
Quando estivermos buscando as mensagens no banco de dados isso fará mais sentido.&lt;/p&gt;

&lt;p&gt;Agora vamos substituir a lógica no arquivo &lt;code&gt;route.js&lt;/code&gt; transferindo a responsabilidade de
recuperar as mensagens para a classe &lt;strong&gt;ChatModel&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando a classe ChatModel
const ChatModel = require(&#39;../models/chatmodel&#39;);

module.exports = function (app) {
    app.get(&#39;/mensagens&#39;, (req, res) =&amp;gt; {
        ChatModel.gelAll((result, error) =&amp;gt; {
            if(error) {
                console.log(&#39;error:&#39;, error);
                return res.status(400).send(error);
            }
            
            return res.send(result);
        });
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima, ao invés de enviarmos direto a mensagem como resposta para o &lt;code&gt;res.send()&lt;/code&gt;,
como estava antes, chamamos o método &lt;code&gt;getAll()&lt;/code&gt; da classe &lt;strong&gt;ChatModel&lt;/strong&gt; que recebe como
parâmetro a arror function de callback que engloba o &lt;code&gt;res.send()&lt;/code&gt;
e que será executada assim que os dados estiverem disponíveis.&lt;/p&gt;

&lt;p&gt;Se você rodar o servidor de novo e testar no navegador vai perceber que ainda
funciona como o esperado. Nada mudou, porém agora temos o modelo responsável pela
nossa lógica por trás do chat.&lt;/p&gt;

&lt;p&gt;Vamos preparar agora nossa aplicação para usar &lt;strong&gt;&lt;em&gt;sockets&lt;/em&gt;&lt;/strong&gt;, que nos permite criar conexões
bidirecionais entre o servidor e os usuários (&lt;em&gt;clients&lt;/em&gt;) da aplicação, montando assim
links de comunicação em tempo real entre os dois. Vamos fazer isso utilizando a
biblioteca &lt;a href=&quot;http://socket.io/&quot;&gt;Socket.io&lt;/a&gt; no back-end (Socket.io Server) e no front-end
(Socket.io Client).&lt;/p&gt;

&lt;h1 id=&quot;integrando-socketio-no-backend&quot;&gt;Integrando Socket.io no Backend&lt;/h1&gt;

&lt;p&gt;O nosso servidor, configurado acima, ficará responsável por gerenciar conexões sockets e
notificar os clientes conectados com novas mensagens de chat.&lt;/p&gt;

&lt;p&gt;Para utilizarmos o &lt;strong&gt;Socket.io&lt;/strong&gt; no servidor precisamos do &lt;strong&gt;Socket.io Server&lt;/strong&gt; que
instalamos via &lt;code&gt;npm&lt;/code&gt; &lt;strong&gt;savando como uma dependêcia&lt;/strong&gt; do nosso projeto:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ npm install --save socket.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se você abrir o arquivo &lt;code&gt;package.json&lt;/code&gt; verá que agora além do Express temos também o Socket.io
registrado como uma dependência, e isso significa que ele também está disponível na
pasta &lt;code&gt;node_modules&lt;/code&gt; onde reside todos os módulos do &lt;code&gt;npm&lt;/code&gt; e nossas dependências.&lt;/p&gt;

&lt;p&gt;Então chega de perder tempo e bora &lt;strong&gt;importá-lo e configurá-lo em nossa aplicação&lt;/strong&gt;. Abra o arquivo app.js e crie mais uma constante que armazenará o resultado da execução deste módulo. O Socket.io ouve mudanças em nosso servidor então precisamos passar o nosso server como parâmetro para ele, então faça isso logo abaixo da &lt;code&gt;const&lt;/code&gt; server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando o Socket.io e executando-o passando nosso server
// como parâmetro
const io = require(&quot;socket.io&quot;).listen(server)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depois disso, logo abaixo, vamos criar um socket para cada novo usuário que se conectar.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// ouvindo o evento &#39;connection&#39; no servidor e criando um novo
// socket para cada nova conexão
io.on(&quot;connection&quot;, socket =&amp;gt; {
    socket.on(&quot;mensagem_mano&quot;, msg =&amp;gt; {
        io.emit(&quot;mensagem_mano&quot;, msg);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entendendo o que fizemos no código acima: A constante &lt;code&gt;io&lt;/code&gt; é o nosso &lt;strong&gt;socket que ouve
mudançascno servidor&lt;/strong&gt;, então &lt;strong&gt;a cada novo usuário&lt;/strong&gt; que entrar na nossa aplicação o
Socket.io vai &lt;strong&gt;executar a função de &lt;em&gt;callback&lt;/em&gt;&lt;/strong&gt; associada ao evento chamado &lt;code&gt;connection&lt;/code&gt;
passando por parâmetro o novo socket criado &lt;strong&gt;especificamente&lt;/strong&gt; para o novo usuário
conectado. A função de &lt;em&gt;callback&lt;/em&gt;, por sua vez,
&lt;strong&gt;através desse socket&lt;/strong&gt;, &lt;strong&gt;criar um novo ouvinte&lt;/strong&gt;, agora para o evento chamado &lt;code&gt;mensagem_mano&lt;/code&gt;, com uma
função de callback que espera um parâmetro que foi denominado, em seu contexto, como &lt;code&gt;msg&lt;/code&gt;.
Quando este evento ocorrer, este ouvinte solicita para &lt;strong&gt;o Socket.io reemitir o mesmo evento&lt;/strong&gt;
fazendo um &lt;em&gt;broadcasting&lt;/em&gt; da mensagem pra &lt;strong&gt;todos os sockets &lt;em&gt;clients&lt;/em&gt; conectados&lt;/strong&gt; no momento,
&lt;strong&gt;inclusive para o usuário que o emitiu&lt;/strong&gt;.
Resumindo, o servidor faz um &lt;em&gt;push&lt;/em&gt; da mensagem para todos os front-end conectados.&lt;/p&gt;

&lt;p&gt;O código final do arquivo app.js então ficaria assim:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando o módulo express
const express = require(&#39;express&#39;);

// criando uma instância do express
const app = express();

// criando o servidor http para a nossa app
const server = require(&quot;http&quot;).Server(app);

// importando o Socket.io e executando-o passando nosso server
// como parâmetro
const io = require(&quot;socket.io&quot;).listen(server);

// ouvindo o evento &#39;connection&#39; no servidor que quando executado, cria um novo
// socket para a conexção recém aberta
io.on(&quot;connection&quot;, socket =&amp;gt; {
    // com o novo socket criado é ciado também um novo ouvinte
    // para o nosso evento
    socket.on(&quot;mensagem_mano&quot;, msg =&amp;gt; {
        // e o Socket.io reenvia pra todos que estão conectados
        io.emit(&quot;mensagem_mano&quot;, msg);
    });
});

// importando nosso arquivo de rotas e executando-o imediatamente 
// depois com a instância do Express sendo passada como parâmetro
const routes = require(&quot;./routes/routes.js&quot;)(app);

server.listen(3000, () =&amp;gt;
    console.log(&quot;Listening on port %s...&quot;, server.address().port));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por hora não temos como testar. No máximo podemos executar &lt;code&gt;$ node app&lt;/code&gt; no terminal e se 
nenhuma mensagem de erro aparecer está tudo ok.&lt;/p&gt;

&lt;p&gt;Precisamos de um jeito para emitir o evento, que definimos acima, com a mensagem do usuário.
Faremos isso no front-end. Vamos criar então um arquivo HTML e um JavaScript bem básicos
apenas para testar o Socket.io.&lt;/p&gt;

&lt;p&gt;Mas antes precisamos definir um local para o nosso front-end. Precisamos de uma pasta
estática onde ficará o nosso front-end e onde, mais adiante, vamos implementar o Angular 2.&lt;/p&gt;

&lt;p&gt;O Node executa todo arquivo JavaScript do lado do servidor. Uma pasta estática em um projeto
Node significa que os arquivos JavaScript contidos nela não serão executados pelo Node e
sim pelo navegador, no lado do cliente. É o que nós precisamos, então vamos seguir e
configurar essa pasta.&lt;/p&gt;

&lt;p&gt;Crie uma pasta chamada &lt;code&gt;public&lt;/code&gt; na raiz do projeto e no arquivo &lt;code&gt;app.js&lt;/code&gt; configure-a como
estática. As novas linhas adicionadas estão destacada com setas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// importando o módulo path do node
const path = require(&#39;path&#39;);

// definindo a pasta public como o local onde o front-end reside
app.use(express.static(path.join(__dirname, &quot;public&quot;)));

Novamente o arquivo app.js na íntegra:

// importando o módulo express
const express = require(&#39;express&#39;);

// criando uma instância do express
const app = express();

// criando o servidor http para a nossa app
const server = require(&quot;http&quot;).Server(app);

// importando o Socket.io e executando-o passando nosso server
// como parâmetro
const io = require(&quot;socket.io&quot;).listen(server);

// ----&amp;gt; importando o módulo path do node
const path = require(&#39;path&#39;); // &amp;lt;----

// ----&amp;gt; definindo a pasta public como o local onde o front-end reside
app.use(express.static(path.join(__dirname, &quot;public&quot;))); // &amp;lt;----

// ouvindo o evento &#39;connection&#39; no servidor e criando um novo
// socket para cada nova conexão
io.on(&quot;connection&quot;, socket =&amp;gt; {
    socket.on(&quot;mensagem_mano&quot;, msg =&amp;gt; {
        io.emit(&quot;mensagem_mano&quot;, msg);
    });
});

// importando nosso arquivo de rotas e executando-o imediatamente 
// depois com a instância do Express sendo passada por parâmetro
const routes = require(&quot;./routes/routes.js&quot;)(app);

server.listen(3000, () =&amp;gt;
    console.log(&quot;Listening on port %s...&quot;, server.address().port));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No códigio acima &lt;strong&gt;importamos o módulo &lt;code&gt;path&lt;/code&gt;&lt;/strong&gt; para nos auxiliar na manipulação de caminhos
de arquivos do servidor e &lt;strong&gt;criamos um Middleware&lt;/strong&gt; com &lt;code&gt;use&lt;/code&gt; avisando ao servidor que a pasta
&lt;code&gt;public&lt;/code&gt; é estática.&lt;/p&gt;

&lt;p&gt;Agora que temos uma pasta estática, &lt;strong&gt;crie os arquivos HTML e JS&lt;/strong&gt; dentro dela, para emitirmos
eventos com o Socket.io precisamos usar a biblioteca &lt;strong&gt;Socket.io Client&lt;/strong&gt; que vamos importar no HTML.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Index.html&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;Socket.io&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;ul class=&quot;messages&quot;&amp;gt;&amp;lt;/ul&amp;gt;
        &amp;lt;input class=&quot;chatBox&quot; placeholder=&quot;Digite aqui...&quot; /&amp;gt;

        &amp;lt;script src=&quot;https://cdn.socket.io/socket.io-1.4.5.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima &lt;strong&gt;criamos uma lista onde as mensagens serão listadas&lt;/strong&gt;, &lt;strong&gt;um &lt;code&gt;input&lt;/code&gt; do tipo
&lt;code&gt;text&lt;/code&gt; para enviar mensagens&lt;/strong&gt; e &lt;strong&gt;adicionamos 2 arquivos JavaScript&lt;/strong&gt;: o primeiro é o &lt;strong&gt;Socket.io Client&lt;/strong&gt; que importamos via &lt;code&gt;CDN&lt;/code&gt; e o &lt;strong&gt;JavaScript da nossa aplicação&lt;/strong&gt; que criaremos abaixo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Index.js&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// Selecionando os elementos do HTML
var $messages = document.querySelector(&#39;.messages&#39;); // área de mensagens
var $inputMessage = document.querySelector(&#39;.chatBox&#39;); // caixa de texto

// Instanciando o Socket.io
var socket = io();

// sempre que o usuário apertar qualquer tecla do teclado em
// qualquer lugar da tela
window.addEventListener(&#39;keydown&#39;, function (event) {
    // Se caso a tecla for enter chama a função que envia
    // a mensagem digitada no input e limpa o input
    if (event.which === 13) {
        sendMessage();
        cleanInput();
    }
});

function cleanInput() {
    $inputMessage.value = &#39;&#39;;
}

function sendMessage() {
    var message = $inputMessage.value;
    console.log(&#39;enviando mensagem&#39;, message);

    // Se a mensagem não for vazia
    if (message) {
        // pede ao servidor para executar o evento &#39;mensagem_mano&#39;
        // e transmitir 1 parâmetro que vai para todos os usuários
        // conectados, inclusive para quem enviou
        socket.emit(&#39;mensagem_mano&#39;, message);
    }
}

// Sempre que o servidor emitir o evento &#39;mensagem_mano&#39;, o socket do
// usuário conectado vai capturar esse evento e chamar a função de callback
// que atualiza a área de mensagem com a nova mensagem recebida
socket.on(&#39;mensagem_mano&#39;, function (msg) {
    console.log(&#39;recebendo a mensagem&#39;, msg);
    var node = document.createElement(&quot;li&quot;);
    var textNode = document.createTextNode(msg);
    node.appendChild(textNode);
    $messages.appendChild(node);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima dispensa explicações. Ele se auto explica em tudo o que está sendo feito.&lt;/p&gt;

&lt;p&gt;Se você rodar o servidor agora vai ver que está tudo funcionando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ node app&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;funcionar-como-antes&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Abra a aplicação em 2 navegadores e faça o teste!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/ezgif.com-video-to-gif.gif&quot; alt=&quot;Ezgif.com-video-to-gif.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nosso Back-end está pronto. Por hora!&lt;/p&gt;

&lt;h1 id=&quot;concluso&quot;&gt;Conclusão&lt;/h1&gt;

&lt;p&gt;Neste artigo/tutorial &lt;strong&gt;configuramos o servidor&lt;/strong&gt; Node com ajuda do Express e
&lt;strong&gt;instalamos o Socket.io Server fizemos a integração&lt;/strong&gt; para criar sockets com usuários e transmitir mensagens em
&lt;em&gt;broadcasting&lt;/em&gt;. A parte do Socket está 100%.]&lt;/p&gt;

&lt;p&gt;Além disso &lt;strong&gt;configuramos a pasta &lt;code&gt;public&lt;/code&gt; como estática&lt;/strong&gt; no servidor para o Node ignorar os arquivos
&lt;code&gt;.js&lt;/code&gt; que pertencem ao front-end.&lt;/p&gt;

&lt;p&gt;Voltaremos ao backend quando formos persistir as mensagens no Couchbase, vou também
explicar as diferenças entre o Couchbase e o MongoDB.&lt;/p&gt;

&lt;p&gt;Do lado do cliente &lt;strong&gt;criamos o Front-end puramente com HTML5 e JavaScript&lt;/strong&gt; e &lt;strong&gt;integramos
com o Socket.io Client&lt;/strong&gt;. Na segunda
parte desse artigo vou mostrar como migrar nosso Front-end para Angular 2, fazer o request
no servidor para buscar as mensagens no end-point que criamos e como integrar o Socket.io-client no
Angular 2 usando observables. Em um próximo artigo, também vou mostrar como fazer tudo isso
com Ionic 2 e Firebase ;)&lt;/p&gt;

&lt;p&gt;O código fonte dessa parte do artigo está disponível no
&lt;a href=&quot;https://github.com/felipeblini/CEAN-Stack-and-Socket.io-chat-tutorial&quot;&gt;GithUB&lt;/a&gt;
na &lt;em&gt;branch&lt;/em&gt; master.&lt;/p&gt;

&lt;p&gt;Deixe o seu comentário, dúvidas e etc… Nos vemos no próximo artigo!&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Feb 2017 22:04:27 -0300</pubDate>
        <link>http://blini.io/criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-1</link>
        <guid isPermaLink="true">http://blini.io/criando-um-chat-realtime-com-cean-stack-couchbase-express-angular2-e-node-e-socketio-part-1</guid>
        
        <category>Socket.io</category>
        
        <category>Websockets</category>
        
        <category>Couchbase</category>
        
        <category>Node</category>
        
        <category>Express</category>
        
        <category>Angular</category>
        
        <category>JavaScript</category>
        
        
        <category>Socket.io</category>
        
        <category>Websockets</category>
        
        <category>Couchbase</category>
        
        <category>Node</category>
        
        <category>Express</category>
        
        <category>Angular</category>
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Parceria Black Week balta.io, Descontos em Cursos Asp.net, Nodejs, Mongodb, Angular, Xamarin, Ionic, Domain Driven Design, Solid, Clean Code e Muito Mais</title>
        <description>&lt;p&gt;Black Friday não, Black Week!&lt;/p&gt;

&lt;p&gt;Na semana entre &lt;strong&gt;21 e 25 de Novembro de 2016&lt;/strong&gt; o &lt;a href=&quot;http://balta.io/&quot;&gt;balta.io&lt;/a&gt;
liberou um descontão pra você que está lendo ou que &lt;a href=&quot;#newsletters&quot;&gt;segue meu blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O conteúdo deles é da melhor qualidade, &lt;strong&gt;5 estrelas mesmo&lt;/strong&gt;, eles contam com mais
&lt;strong&gt;80 cursos TOP&lt;/strong&gt; que com certeza elevarão seu nível de desenvolvedor mediano para NINJA!&lt;/p&gt;

&lt;p&gt;São &lt;strong&gt;cursos online em vídeo aulas&lt;/strong&gt; de excelente qualidade e suporte a dúvidas.
Você vai aprender do básico ao avançado e tudo do que há de mais novo no mundo &lt;strong&gt;ASP.NET&lt;/strong&gt;,
&lt;strong&gt;NodeJs&lt;/strong&gt;, &lt;strong&gt;MongoDB&lt;/strong&gt;, &lt;strong&gt;Angular&lt;/strong&gt;, &lt;strong&gt;Xamarin&lt;/strong&gt;, &lt;strong&gt;Ionic&lt;/strong&gt;, &lt;strong&gt;Domain Driven Design&lt;/strong&gt;,
&lt;strong&gt;SOLID&lt;/strong&gt;, &lt;strong&gt;Clean Code&lt;/strong&gt; e muito mais.&lt;/p&gt;

&lt;p&gt;Além destes conteúdos, você ainda poderá desfrutar de todos os futuros cursos adicionados
até o fim da sua assinatura sem pagar nada a mais por isto!&lt;/p&gt;

&lt;p&gt;O site é encabeçado por &lt;a href=&quot;https://www.facebook.com/profile.php?id=540743591&quot;&gt;André Baltieri&lt;/a&gt;,
referência na comunidade e um profissional muito conceituado no mercado, além de ser muito
gente boa e estar sempre disponível nas redes sociais.
E ele ainda tem um &lt;a href=&quot;https://www.facebook.com/groups/balta.io/&quot;&gt;grupo específico para alunos no Facebook&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;corra-porque-esta-promoo-vai-at-a-meia-noite-desta-sexta-25112016&quot;&gt;Corra porque esta promoção vai até a meia noite desta sexta!! (25/11/2016).&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Acesse o link abaixo&lt;/strong&gt; e comece agora mesmo o seu processo de transformação ninja
com um desconto especial de Black Friday!&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: 30px&quot;&gt;&lt;a href=&quot;http://bit.ly/2g88cL6&quot;&gt;http://bit.ly/2g88cL6&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Nov 2016 19:49:54 -0300</pubDate>
        <link>http://blini.io/black-week-descontos-em-cursos-aspnet-nodejs-mongodb-angular-xamarin-ionic-domain-driven-design-solid-clean-code-e-muito-mais</link>
        <guid isPermaLink="true">http://blini.io/black-week-descontos-em-cursos-aspnet-nodejs-mongodb-angular-xamarin-ionic-domain-driven-design-solid-clean-code-e-muito-mais</guid>
        
        <category>promoções</category>
        
        <category>cursos</category>
        
        
        <category>promoções</category>
        
        <category>cursos</category>
        
      </item>
    
      <item>
        <title>Classes e Objetos em Javascript</title>
        <description>&lt;p&gt;O ECMAScript 2015 trouxe a implementação da palvara reservada &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt;,
porém isso não trouxe a capacidade de orientação a objetos ao JavaScript. Essa capacidade já existia desde
as primórdios da linguagem, tanto é que &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; sempre foi
uma palavra-chave reservada, mesmo não tendo nenhuma utilidade no passado. Isso também não alterou o sistema
de orientação a objetos do JavaScript. A palavra-chave &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; é apenas um açucar
sintático para fazermos exatamente o que já fazíamos antes: &lt;em&gt;funções construtoras de objetos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por isso estudar e entender o jeito antigo de criar classes, objetos e heranças é essencial para um bom
programador JavaScript pois debaixo dos panos tudo ainda acontece do mesmo jeito.&lt;/p&gt;

&lt;p&gt;Você talvez tenha ouvido falar, no passado, que o JavaScript não é uma linguagem orientada a objetos.
Mas sim, o JavaScript sempre foi uma linguagem orientada a objetos. A verdade é que ele
tem uma orientação a objetos completa que é muito mais potente que várias linguagens
clássicas por aí.&lt;/p&gt;

&lt;p&gt;Sempre houve tipos primitivos e objetos no JavaScript, sendo 5 os tipos primitivos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;boolean&lt;/li&gt;
  &lt;li&gt;number&lt;/li&gt;
  &lt;li&gt;string&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sendo que &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt; e &lt;em&gt;string&lt;/em&gt; possuem suas versões em classes, diferenciados pela primeira
letra em maiúscula:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boolean&lt;/li&gt;
  &lt;li&gt;Number&lt;/li&gt;
  &lt;li&gt;String&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Um objeto base o qual todos os outros objetos herdam&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;Object&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;E as 4 capacidades básicas de uma linguagem orientada a objetos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Encapsulamento&lt;/li&gt;
  &lt;li&gt;Agregação&lt;/li&gt;
  &lt;li&gt;Herança, e&lt;/li&gt;
  &lt;li&gt;Polimorfismo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Criar objetos em JavaScript é trivial. Isso pode ser feito de diversas formas.
A maneira mais simples é com objetos Literais:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var obj = {};

// verificando o tipo da variável obj
console.log(typeof obj); // &quot;object&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos também criar usando a classe &lt;strong&gt;&lt;em&gt;Object&lt;/em&gt;&lt;/strong&gt; mencionada acima:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var obj = new Object();

// verificando o tipo da variável obj
console.log(typeof obj); // &quot;object&quot;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para adicionar propriedades e métodos a um objeto literal é muito simples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// passando as propriedades e métodos na criação do objeto literal
var obj = {
    // propriedades
    nome: &#39;banana&#39;,
    cor: &#39;amarelo&#39;,

    // métodos
    toString: function() {
        console.log(this.nome + &quot;, &quot; + this.cor);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note que separamos as propriedades e os métodos por vírgula. O JavaScript é uma linguagem muito
dinâmica, então podemos atachar métodos e propriedades dinamicamente
em tempo de execução:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var fruta = {};

// propriedades
fruta.nome = &#39;pêra&#39;;
fruta.cor = &#39;verde&#39;;

// métodos
fruta.toString = function() {
    console.log(this.nome + &quot;, &quot; + this.cor);
}

fruta.toString(); // &#39;pêra, verde&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note também que usamos a palavra-chave reservada &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt; dentro dos métodos.
O &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt; nesse caso represent a o dono do método, nesse caso o 
objeto &lt;code class=&quot;inline&quot;&gt;fruta&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt; no JavaScript nem sempre é o que esperamos que seja. O valor
dele depende muito do contexto e estar confortável sobre o valor do &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;
no JavaScript é talvez o mais complicado da linguagem.&lt;/p&gt;

&lt;p&gt;Ok, criamos nossos primeiros objetos. Agora vamos criar novas frutas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var banana = new fruta(); // TypeError: fruta is not a constructor&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ops, deu erro. Os códigos acima criam apenas objetos literais para uso imediato, para serem passados
por parâmetro, para encapsularem dados e/ou funções, entre outos usos, muito útil em programação
funcional, mas não muito usual em programação orientada a objetos.&lt;/p&gt;

&lt;p&gt;Para criarmos novas instâncias do nosso objeto &lt;code class=&quot;inline&quot;&gt;fruta&lt;/code&gt;,
com dados diferentes para cada uma, precisamos fazer uso de classes e no JavaScript
classes são &lt;em&gt;Funções Construtoras&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;funes-construtoras&quot;&gt;Funções Construtoras&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Classes em JavaScript são funções construtoras&lt;/strong&gt; de objetos. Como qualquer classe em orientação a objetos, elas possuem
estado (locais para armazenamento de dados) e comportamento (funcionalidades e métodos públicos e privados).&lt;/p&gt;

&lt;p&gt;O estado do objeto são variáveis e os métodos, além das classes, também são funções.
Podemos verificar isso investigando o objeto &lt;em&gt;String&lt;/em&gt; do JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// o objeto String é uma função
console.log(typeof String); // &quot;function&quot;

// criando uma instância do objeto String
var st = new String(&quot;abc&quot;);

// o método split do objeto String também é uma função
console.log(typeof st.split); // &quot;function&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com isso comprovamos que classes e métodos em JavaScript são todos funções. Isso é possível
pois funções no JavaScript são objetos de primeira classe, isso significa que podemos
tratá-las como qualquer outro objeto, passando-as como parâmetro para outras funções,
assinalando-as a variáveis e por ai em diante.&lt;/p&gt;

&lt;p&gt;A diferença de funções construtoras é que elas servem para construir e retornar novos objetos.&lt;/p&gt;

&lt;p&gt;É muito simples criar uma função construtora. Basta criar uma função que não retorna nada. Por
convenção usamos a primeira letra em maiúscula:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta() {};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E usamos da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var banana = new Fruta();
var morango = new Fruta();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muito simples!&lt;/p&gt;

&lt;p&gt;Agora vamos deixá-la mais usual, parecendo-se mais com uma classe.&lt;/p&gt;

&lt;p&gt;Para que possamos instanciar novos objetos com estados e comportamente, precisamos fazer o 
uso do &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;, como mostrado a seguir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    this.nome = nome;
    this.cor = cor;
    this.toString = function() {
        console.log(this.nome + &quot;, &quot; + this.cor);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora podemos criar novas instâncias de Fruta com dados:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var banana = new Fruta(&#39;banana&#39;, &#39;amarelo&#39;);
var pera = new Fruta(&#39;pêra&#39;, &#39;verde&#39;);

banana.toString(); // &quot;banana, amarelo&quot;
pera.toString(); // &quot;pêra, verde&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acabamos de criar uma classe em JavaScript e duas instâncias dessa classe.&lt;/p&gt;

&lt;p&gt;A classe que criamos acima é uma função construtora que define propriedades e métodos com o &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;.
Com isso conseguimos novas instâncias dessa classe executando a função precedida da palavra-chave
&lt;code class=&quot;inline&quot;&gt;new&lt;/code&gt; que retornará um novo objeto.&lt;/p&gt;

&lt;p&gt;Todo objeto em JavaScript criado com a palavra-chave &lt;code class=&quot;inline&quot;&gt;new&lt;/code&gt;
tem uma propriedade extra chamada &lt;code class=&quot;inline&quot;&gt;constructor&lt;/code&gt; que aponta de volta
para a função construtora usada para construí-lo. Podemos checar isso da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;console.log(banana.constructor);

/* imprime: function Fruta(nome, cor) {
  this.nome = nome;
  this.cor = cor;
  this.toString = function () {
      window.runnerWindow.proxyConsole.log(this.nome + &quot;, &quot; + this.cor);
  };
}*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos até criar novas instâncias da classe com a propriedade &lt;code class=&quot;inline&quot;&gt;constructor&lt;/code&gt;
através de qualquer instância da classe:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var pera = new banana.constructor(&quot;pêra&quot;, &quot;verde&quot;);

pera.toString(); // &quot;pêra, verde&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nos exemplos acima estamos usando, além de classes e objetos, um conceito muito básico
do paradigma de orientação a objetos: &lt;strong&gt;polimorfismo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Toda função em JavaScript herda
de &lt;em&gt;Object&lt;/em&gt;. O &lt;em&gt;Object&lt;/em&gt; é uma classe/função construtora e possui um método chamado
&lt;code class=&quot;inline&quot;&gt;toString()&lt;/code&gt; que está sendo sobrescrito na nossa classe
construtora Fruta pelo método de mesmo nome &lt;code class=&quot;inline&quot;&gt;toString()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podemos checar essa herança da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var banana = new Fruta(&#39;banana&#39;, &#39;amarelo&#39;);
var pera = new Fruta(&#39;pêra&#39;, &#39;verde&#39;);

// verificando se nossos objetos fruta são instâncias de Fruta
console.log(banana instanceof Fruta); // true
console.log(pera instanceof Fruta); // true

// verificando se a função construtora Fruta é uma instâcia/herda de Object
console.log(Fruta instanceof Object); // true

// do mesmo jeito que String, Boolean e Number também são instâncias/herdam de Object
console.log(String instanceof Object); // true
console.log(Boolean instanceof Object); // true
console.log(Number instanceof Object); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;we-have-a-problem-captain&quot;&gt;We Have a Problem Captain&lt;/h2&gt;

&lt;p&gt;Criar múltiplas instâncias de objetos usando a estrutura do código anterior
consome bastante memória pois, nessa abordagem, cada instância de um objeto é
completamente distinta das outras, ou seja, elas são instâncias do mesmo objeto porém
não compartilham nada entre si. São completamente independentes.&lt;/p&gt;

&lt;p&gt;Isso significa que as funções usadas nos métodos de cada instância da classe não
compartilham o mesmo espaço de memória.&lt;/p&gt;

&lt;p&gt;Podemos verificar isso no código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    this.nome = nome;
    this.cor = cor;
    this.toString = function() {
        console.log(this.nome + &quot;, &quot; + this.cor);
    }
}

var banana = new Fruta(&quot;banana&quot;, &quot;amarelo&quot;);
var banana2 = new Fruta(&quot;banana&quot;, &quot;amarelo&quot;);

// Para cada instância é criada uma nova função diferente para toString()
console.log(banana.toString === banana2.toString); // false

// O que é um desperdiço de memória já que elas fazem exatamente a mesma coisa
banana.toString(); // &quot;banana, amarelo&quot;
banana2.toString(); // &quot;banana, amarelo&quot;

// E se quisermos extender um método em tempo de execução,
// teremos que alterar instância por instância 
banana2.toString = function() {
    console.log(&quot;&quot;);
}

banana.toString(); // &quot;banana, amarelo&quot;
banana2.toString(); // &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Além disso, já que essas instâncias não compartilham nada entre si, não conseguimos extender
a classe dinamicamente, teremos que alterar cada uma das instâncias da classe unicamente.&lt;/p&gt;

&lt;p&gt;Aterar funcionalidades de uma instância única, sem passar pela classe e sem compartilhar
com as outras instâncias, é uma característica muito comum em &lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_programming_language&quot;&gt;linguagens dinâmicas&lt;/a&gt;
e é conhecida como &lt;a href=&quot;https://en.wikipedia.org/wiki/Monkey_patch&quot;&gt;Monkey patch&lt;/a&gt;, encontrada também em
&lt;a href=&quot;https://www.ruby-lang.org/en/&quot;&gt;Ruby&lt;/a&gt;, &lt;a href=&quot;https://www.python.org/&quot;&gt;Phyton&lt;/a&gt;
e diversas outras linguagens dinâmicas.&lt;/p&gt;

&lt;p&gt;Porém esse comportamento pode nos trazer grandes problemas lidando com programação orientada
a objetos, por isso é uma má prática, pois em algum momento ficaremos confusos em relação ao que
cada instância do objeto pode ou não fazer e qual é realmente a responsabilidade
da classe que os criou, causando muitas vezes comportamentos estranhos. Além de tudo,
estaremos ferindo os dois primeiros princípios básicos de orientação a objetos definidos
em &lt;a href=&quot;https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)&quot;&gt;S.O.L.I.D&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Em alguns casos, como em programação funcional, esse comportamento certamente é de
bom uso. Porém, em orientação a objetos sempre é uma melhor prática extender a classe.&lt;/p&gt;

&lt;h2 id=&quot;porqu-o-padro-prototypes--o-ideal&quot;&gt;Porquê o Padrão &lt;em&gt;prototypes&lt;/em&gt; é o Ideal?&lt;/h2&gt;

&lt;p&gt;Toda função em JavaScript, e portanto toda função construtora, tem um protótipo. O protótipo
de uma função é uma propriedade dela que descreve seus métodos e propriedades. Podemos extender esses métodos alterando o
protótipo da função e/ou herdando o protótipo de outra função.&lt;/p&gt;

&lt;p&gt;Esse protótipo está disponível em uma propriedade chamada &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;.
Toda função em JavaScript tem essa propriedade.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt; é um objeto
que contém todos os métodos e propriedades associados a uma instância de uma função/classe criada com a palavra-chave &lt;code class=&quot;inline&quot;&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O protótipo de toda função é &lt;em&gt;Object&lt;/em&gt; e pode ser extendido. Vamos analisar nossa função/classe Fruta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    this.nome = nome;
    this.cor = cor;
}

console.log(&#39;Protótipo de Fruta:&#39;, Fruta.prototype); // &quot;Protótipo de Fruta:&quot; [object Object] { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como esperado o protótipo da nossa função Fruta é o obeto &lt;em&gt;Object&lt;/em&gt; que, como já mencionado, é
a função construtora de todas as funções no JavaScript.&lt;/p&gt;

&lt;p&gt;Sabendo que o JavaScript é uma linguagem dinâmica e com esse nosso novo conhecimento de que
funções têm a propriedade &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt; e que essa é um objeto,
podemos adicionar nossas próprias propriedades e métodos nesse objeto.&lt;/p&gt;

&lt;p&gt;Vamos criar a mesma classe Fruta usando &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt; e entender
como que com prototype instânciamos objetos de maneira mais eficiente.&lt;/p&gt;

&lt;h3 id=&quot;mtodos-no-prototype&quot;&gt;Métodos no Prototype&lt;/h3&gt;

&lt;p&gt;Nesse exemplo mostro como adicionar métodos no &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt; ao
invés de colocar direto no &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt; e qual é a diferença.&lt;/p&gt;

&lt;p&gt;Além disso vamos ver que métodos e variáveis privadas são definidos dentro da classe, fora
do &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    this.nome = nome;
    this.cor = cor;

    // variável acessível apenas dentro da classe
    var _variavelPrivada;
  
    this.metodoPrivilegiado = function () { 
        // privilegiado pois acessa variáveis privadas e é acessível externamente 
        _variavelPrivada = 0;
        console.log(_variavelPrivada);
    };
}

// adicionando o método toString à nossa classe
Fruta.prototype.toString = function() {
    console.log(this.nome + &quot;, &quot; + this.cor);
}

var banana = new Fruta(&quot;banana&quot;, &quot;amarelo&quot;);
var pera = new Fruta(&quot;pêra&quot;, &quot;verde&quot;);
var laranja = new Fruta(&quot;laranja&quot;, &quot;laranja&quot;);

// A definição da função toString() é compartilhada entre as instâncias
console.log(banana.toString === pera.toString); // true

// O que é um disperdiço de memória já que elas fazem a mesma coisa
banana.toString(); // &quot;banana, amarelo&quot;
pera.toString(); // &quot;pêra, verde&quot;
laranja.toString(); // &quot;laranja, laranja&quot;

// mudanças no prototype afetam todas as instâncias existentes
// e futuras da classe
Fruta.prototype.toString = function() {
    console.log(this.nome.split(&quot;&quot;).reverse().join(&quot;&quot;));
}

banana.toString(); // &quot;ananab&quot;
pera.toString(); // &quot;arêp&quot;
laranja.toString(); // &quot;ajnaral&quot;

// podemos redefinir dinamicamente um método de uma única instância
// o JavaScript vai criar uma função separada somente para ele
pera.toString = function() {
    console.log(&quot;&quot;);
}

// pera agora tem o metodo toString independente
console.log(banana.toString === pera.toString); // false

banana.toString(); // &quot;ananab&quot;
pera.toString(); // &quot;&quot;
laranja.toString(); // &quot;ajnaral&quot;


// toString de banana e laranja continuam sendo a mesma função
console.log(banana.toString === laranja.toString); // true

// acessando variável privada
banana.metodoPrivilegiado(); // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como a propriedade &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt; é um objeto, podemos também definir
nossas propriedades e métodos no estilo de objetos literais:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta() {}

// adicionando o método toString à nossa classe
Fruta.prototype = {
    nome: &quot;&quot;,
    cor: &quot;&quot;,

    setNome: function(nome) {
        this.nome = nome;
    },

    setCor: function(cor) {
        this.cor = cor;
    },

    toString: function() {
        console.log(this.nome + &quot;, &quot; + this.cor);
    }
}

var banana = new Fruta();
banana.setNome(&quot;banana&quot;);
banana.setCor(&quot;amarelo&quot;);

var pera = new Fruta();
pera.setNome(&quot;pêra&quot;);
pera.setCor(&quot;verde&quot;);

var laranja = new Fruta();
laranja.setNome(&quot;laranja&quot;);
laranja.setCor(&quot;laranja&quot;);

banana.toString(); // &quot;banana, amarelo&quot;
pera.toString(); // &quot;pêra, verde&quot;
laranja.toString(); // &quot;laranja, laranja&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note que podemos assinalar propriedades e funções no &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;.
Porém variáveis de instância como &lt;code class=&quot;inline&quot;&gt;nome&lt;/code&gt; e &lt;code class=&quot;inline&quot;&gt;cor&lt;/code&gt;
são dados específicos de cada instâncias e o JavaScript vai criar referências únicas
para cada propriedade de qualquer forma, não tendo assim diferença no impacto de uso da memória.&lt;/p&gt;

&lt;p&gt;Sabendo disse é considerado por convenção uma boa prática definir métodos no &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;
e propriedades no &lt;code class=&quot;inline&quot;&gt;this&lt;/code&gt;, dentro da função.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    // propriedades dentro da função, usando o this
    this.nome = nome;
    this.cor = cor;
}

// e métodos no prototype
Fruta.prototype.toString = function() {
    console.log(this.nome + &quot;, &quot; + this.cor);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;encapsulamento-mtodos-estticos-e-propriedades-estticas&quot;&gt;Encapsulamento, métodos estáticos e propriedades estáticas&lt;/h2&gt;

&lt;p&gt;No código abaixo temos uma abordagem de como podemos encapsular uma variável privada, criar
métodos privados e estáticos assim como valores estáticos como é o caso de um contador de 
instâncias da classe.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Fruta(nome, cor) {
    this.nome = nome;
    this.cor = cor;

    // incrementa quantidade de objetos instanciados
    // executado toda vez que uma instância é criada
    Fruta.incrementaQntInstancia();

    // propriedade privada, é acessada somente dentro da classe
    var _variavelPrivada = 0;

    // método privado, é acessado somente dentro da classe
    function metodoPrivado() {
        _variavelPrivada++;
    }

    // métodos privilegiados, é público e tem acesso a variáveis privadas,
    // é único para cada instância
    this.incrementaVariavelPrivada = function() {
        metodoPrivado();
    }

    // encapsulando a variável privada
    this.getVariavelPrivada = function() {
        return _variavelPrivada;
    }

    this.setVariavelPrivada = function(valor) {
        _variavelPrivada = valor;
    }
}

// adicionando o método toString à nossa classe via prototype
// ficando assim compartilhado entre as instância e extensível
Fruta.prototype.toString = function() {
    console.log(this.nome + &quot;, &quot; + this.cor);
}

// propriedade estática, instâncias não tem acesso 
Fruta.qntInstancias = 0;

// método estático, instâncias não tem acesso 
Fruta.incrementaQntInstancia = function() {
    Fruta.qntInstancias++;
};

var banana = new Fruta(&quot;banana&quot;, &quot;amarelo&quot;);
var pera = new Fruta(&quot;pêra&quot;, &quot;verde&quot;);
var laranja = new Fruta(&quot;laranja&quot;, &quot;laranja&quot;);
var morango = new Fruta(&quot;morango&quot;, &quot;vermelho&quot;);

// imprime propriedade estática da classe Fruta
console.log(&quot;Quantidade de instâncias de Fruta: &quot; + Fruta.qntInstancias); // 4

banana.setVariavelPrivada(1);
pera.setVariavelPrivada(2);
laranja.setVariavelPrivada(3);
morango.setVariavelPrivada(4);

banana.incrementaVariavelPrivada();

console.log(&quot;Variável privada de banana: &quot; + banana.getVariavelPrivada()); // 2
console.log(&quot;Variável privada de pera: &quot; + pera.getVariavelPrivada()); // 2
console.log(&quot;Variável privada de laranja: &quot; + laranja.getVariavelPrivada()); // 3
console.log(&quot;Variável privada de morango: &quot; + morango.getVariavelPrivada()); // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;funesobjetosarrays&quot;&gt;Funções/Objetos/Arrays&lt;/h2&gt;

&lt;p&gt;Uma coisa legal de entender em JavaScript é que funções são objetos de primeira classe e
objetos, em seu nível mais baixo, são arrays associativos de chave e valor. Então funções
também são arrays.&lt;/p&gt;

&lt;p&gt;Cada propriedade e método de um objeto é definido como um item de array.&lt;/p&gt;

&lt;p&gt;Podemos comprovar isso acessando propriedades e métodos em &lt;em&gt;array style&lt;/em&gt; e percorrendo
os itens desse array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var banana = new Fruta(&quot;banana&quot;, &quot;amarelo&quot;);

// acessando propriedades
console.log(banana.nome); // &quot;banana&quot;
// ou
console.log(banana[&quot;nome&quot;]); // &quot;banana&quot;

// executando o método toString()
banana.toString(); // &quot;banana, amarelo&quot;
// ou
banana[&quot;toString&quot;](); // &quot;banana, amarelo&quot;

// percorrendo os itens do array
for(item in banana) {
    console.log(item); // &quot;nome&quot;, &quot;cor&quot;, &quot;toString&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos também definir métodos estáticos para nossa função/classe e acessá-los depois
estaticamente também em &lt;em&gt;array style&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var Fruta = function(nome, cor) {
    this.nome = nome;
    this.cor = cor;
}

// definindo uma propriedade estática
Fruta[&#39;qntInstancias&#39;] = 0;

// definindo um método estático que incrementa a propriedade estática
Fruta[&#39;incrementaQntInstancia&#39;] = function() {
    Fruta[&#39;qntInstancias&#39;]++;
};

// executanto o método estático
Fruta[&#39;incrementaQntInstancia&#39;]();

// imprimindo o novo valor da propriedade estática
console.log(Fruta[&#39;qntInstancias&#39;]);  // 1

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;prototypal-inheritance&quot;&gt;Prototypal Inheritance&lt;/h2&gt;

&lt;p&gt;Podemos fazer uma herança prototípica e extender a classe Fruta adicionando novas funcionalidades
a ela.&lt;/p&gt;

&lt;p&gt;Isso é conhecido como &lt;a href=&quot;https://en.wikipedia.org/wiki/Prototype-based_programming&quot;&gt;Prototypal Inheritance&lt;/a&gt;.
O JavaScript não tem um sistema de herança devido a sua natureza prototípica e funcional.
Porém podemos combinar funções através de seus protótipo.&lt;/p&gt;

&lt;p&gt;Podemos tabém sobrescrever métodos da superclasse em nossa subclasse chamando nossa
classe/função através do método &lt;code class=&quot;inline&quot;&gt;.call()&lt;/code&gt; existente em toda função
Javascript.&lt;/p&gt;

&lt;p&gt;Vamos supor que queremos que Fruta herde as funcionalidades de uma classe chamada Natureza com
os métodos nascer, crescer e morrer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// criando a superclasse Natureza
function Natureza(nome, cor) {
    this.nome = nome;
    this.cor = cor;
};

// Adicionando comportamentos em seu objeto prototype
Natureza.prototype.nascer = function () {
    console.log(this.nome + &#39; &#39; + this.cor + &#39; nascendo...&#39;);
}

Natureza.prototype.crescer = function () {
    console.log(this.nome + &#39; &#39; + this.cor + &#39; crescendo...&#39;);
}

Natureza.prototype.morrer = function () {
    console.log(this.nome + &#39; &#39; + this.cor + &#39; morrendo...&#39;);
}

// checando o protótipo de Natureza
console.log(&#39;Protótipo de Natureza&#39;, Natureza.prototype);

/* &quot;Protótipo de Natureza&quot;
[object Object] { -&amp;gt; Percebe-se que Natureza herda todos métodos de Object adicionando
seus próprios métodos abaixo:
crescer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; crescendo...&#39;);
},
morrer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; morrendo...&#39;);
},
nascer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; nascendo...&#39;);
}
}*/

// criando a subclasse Fruta
function Fruta(nome, cor, temSemente) {
    // chamando o construtor da superclasse e passando
    // o objeto atual como contexto
    Natureza.call(this, nome, cor);

    this.temSemente = temSemente;
};

// checando o protótipo de Fruta
console.log(&#39;Protótipo de Fruta&#39;, Fruta.prototype);

// como esperado o protótipo de Fruta é Object
// &quot;Protótipo de Fruta&quot; [object Object] {

// extendendo Fruta (herança prototípica)
Fruta.prototype = Natureza.prototype;

// adicionando um método específico para frutas
Fruta.prototype.temSemente = function() {
    console.log(this.temSemente);
}

// checando novamente o protótipo de Fruta
console.log(&#39;Novo Protótipo de Fruta&#39;, Fruta.prototype);

/* Fruta agora tem todos os métodos de Object, todos os métodos de Natureza
e o seu método especializado temSemente()
&quot;Novo Protótipo de Fruta&quot;
[object Object] {
crescer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; crescendo...&#39;);
},
morrer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; morrendo...&#39;);
},
nascer: function () {
    window.runnerWindow.proxyConsole.log(this.nome + &#39; &#39; + this.cor + &#39; nascendo...&#39;);
},
temSemente: function () {
    window.runnerWindow.proxyConsole.log(this.temSemente);
}
} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora podemos utilizar nossa classe Fruta da seguinte maneira:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var uva = new Fruta(&quot;uva&quot;, &quot;roxa&quot;, true);
var morango = new Fruta(&quot;morango&quot;, &quot;vermelho&quot;, false);

uva.nascer(); // &quot;uva roxa nascendo...&quot;
morango.nascer(); // &quot;morango vermelho nascendo...&quot;

uva.crescer(); // &quot;uva roxa crescendo...&quot;
morango.crescer(); // &quot;morango vermelho crescendo...&quot;

uva.morrer(); // &quot;uva roxa morrendo...&quot;
morango.morrer(); // &quot;morango vermelho morrendo...&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Herança prototípica é mais potente que a herança tradicional encontrada em muitas linguagens
tradicionais, pois com protótipos é possível herdar várias classes e criar uma nova classe.
Com isso podemos herdar comportamentos de duas ou mais
classes na nossa classe Fruta. Por exemplo, Fruta tem comportamentos da classe Natureza e pode
ter comportamento de uma nova classe chamada FrutasDoPoloNorte com um método chamado seProtegerDoFrio.&lt;/p&gt;

&lt;h1 id=&quot;objectcreate&quot;&gt;Object.create()&lt;/h1&gt;

&lt;p&gt;O ECMAScript 5 introduziu o método estático &lt;code class=&quot;inline&quot;&gt;create&lt;/code&gt; no objeto
&lt;code class=&quot;inline&quot;&gt;Object&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create()&lt;/a&gt;
permite-nos construir objetos de uma maneira muito simples com os parâmetros opcionais
&lt;code class=&quot;inline&quot;&gt;proto&lt;/code&gt; que especifica o protótipo no qual o novo objeto será baseado e
&lt;code class=&quot;inline&quot;&gt;propertiesObject&lt;/code&gt; que especifica propriedades e descritores dessas
propriedades que serão atachadas no novo objeto criado. Sua sintaxe é a seguinte:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object.create(proto, [, propertiesObject])&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Como os objetos literais criados em tempo de execução, &lt;code class=&quot;inline&quot;&gt;Object.create()&lt;/code&gt;
não é muito usual em programação orientada a objetos, porém é muito útil em programação
funcional.&lt;/p&gt;

&lt;p&gt;Esse método é apenas uma maneira mais fácil de criarmos objetos literais e únicos,
mencionados no começo desse artigo.&lt;/p&gt;

&lt;p&gt;Ao invés de fazermos isso:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// cria um objeto herdando o protótipo de Object  
var obj = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora podemos definir explicitamente qual o protótipo queremos herdar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// cria um objeto herdando o protótipo de Object 
var obj = Object.create(Object.prototype);

// o mesmo resultado acima é obtido com:
var obj = Object.create({});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function MyClass() {}

// cria um objeto herdando o protótipo de MyClass 
var obj = Object.create(MyClass.prototype);

console.log(obj.constructor); // function MyClass() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temos também a possibilidade de definir propriedades do objeto com os descritores 
&lt;code class=&quot;inline&quot;&gt;writable&lt;/code&gt; que indica se o campo é apenas leitura ou não,
&lt;code class=&quot;inline&quot;&gt;enumerable&lt;/code&gt; indicando se essa propriedade pode ser listada em um laço,
&lt;code class=&quot;inline&quot;&gt;configurable&lt;/code&gt; que define se o tipo da propridade pode mudar e se
ela pode ser deletada do objeto correspondente e &lt;code class=&quot;inline&quot;&gt;value&lt;/code&gt; definindo
o valor da propriedade.&lt;/p&gt;

&lt;p&gt;Isso é bem comum em &lt;em&gt;Factory Functions&lt;/em&gt; (funções que constróem objetos para nós) em diversos frameworks
e bibliotecas que usamos no dia-a-dia. O &lt;a href=&quot;https://jquery.com/&quot;&gt;JQuery&lt;/a&gt; por exemplo
usa muito &lt;code class=&quot;inline&quot;&gt;Object.create()&lt;/code&gt; debaixo dos panos para nos entregar
objetos prontos para nosso uso.&lt;/p&gt;

&lt;p&gt;Abaixo temos uma &lt;em&gt;Factory Function&lt;/em&gt; chamada &lt;code class=&quot;inline&quot;&gt;objFactory&lt;/code&gt; que constrói
e nos retorna um objeto com uma propriedade &lt;code class=&quot;inline&quot;&gt;p&lt;/code&gt; somente leitura e que não pode
ser excluída.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var MyClass = function() {};

function objFactory(p) {
    // cria um objeto herdando o protótipo de MyClass e com propriedas definidas 
    return Object.create(MyClass.prototype, { p: {
                value: p,
                writable: false,
                enumerable: true,
                configurable: false
            }
        }); 
}

// pede para o factory construir o objeto com o valor de p igual a 42 
var obj = objFactory(42)

console.log(obj.p); // 42

// alterando o valor da propriedade p
obj.p = 1000;

// p continua 42 pois o writable dele está como false
console.log(obj.p); // 42

// deletando a propriedade p
delete obj.p;

// p continua existindo pois configurable foi definida como false
console.log(obj.p); // 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sempre que você tiver uma função construtora e você estiver instanciando apenas um
objeto com ela usando &lt;code class=&quot;inline&quot;&gt;new&lt;/code&gt;, talvez fique mais elegante você
substituir isso por &lt;code class=&quot;inline&quot;&gt;Object.create()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podemos aplicar isso também ao fazer a herança prototípica da nossa classe Fruta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Fruta.prototype = Object.create(Natureza.prototype);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;as-palavras-chaves-class-e-extends&quot;&gt;As Palavras-Chaves &lt;em&gt;class&lt;/em&gt; e &lt;em&gt;extends&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;O ECMAScript 2015 implementou as palavras-chaves &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; e 
&lt;code class=&quot;inline&quot;&gt;extends&lt;/code&gt; que são nada mais que açúcares sintáticos para
&lt;em&gt;Funções Construtoras&lt;/em&gt; e herança usando &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para chegarmos no mesmo resultado da nossa classe Fruta anterior, fazemos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;class MinhaClasseFruta {
    constructor(nome, cor) {
        this.nome = nome;
        this.cor = cor;
    }
        
    toString () {
        // aqui podemos chamar o método toString() da classe mãe Object
        super.toString();

        // e/ou colocar nosso código especializado 
        console.log(this.nome + &quot;, &quot; + this.cor);
    }
}

var banana = new MinhaClasseFruta(&#39;banana&#39;, &#39;amarelo&#39;);
var uva = new MinhaClasseFruta(&#39;uva&#39;, &#39;roxa&#39;);

// comprovando que, assim como prototype, os métodos de class são compartilhado
// entre suas instâncias
console.log(banana.toString === uva.toString); // true

banana.toString(); // &#39;banana, amarelo&#39;
uva.toString(); // &#39;uva, roxa&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code class=&quot;inline&quot;&gt;Fruta&lt;/code&gt; criada no primeiro exemplo e a classe
criada com a nova implementação de &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; ambas são &lt;em&gt;Funções
Construtoras&lt;/em&gt;, por isso &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; também herda de &lt;em&gt;Objects&lt;/em&gt;
implicitamente e são usadas do mesmo jeito: executando-as com a palavra-chave
&lt;code class=&quot;inline&quot;&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, classes também são funções no JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// retornam uma nova instância de objeto
var banana = new MinhaClasseFruta(&#39;banana&#39;, &#39;amarelo&#39;);

console.log(banana); // [object Object] {
  // cor: &quot;amarelo&quot;,
  // nome: &quot;banana&quot;
// }

// classes continuam sendo função
console.log(MinhaClasseFruta); // function () { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; retornam uma nova instância de objeto e também é baseada
em &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Agora herdando da superclasse Natureza:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// criando a superclasse Natureza
class Natureza {
    constructor(nome) {
        this.nome = nome;
    }
    
    toString() {
        return this.nome;
    }
};

// criando a subclasse Fruta
class Fruta extends Natureza {
    constructor(nome, cor, temSemente) {
        // chamando o construtor da superclasse
        super(nome);

        this.cor = cor;
        this.temSemente = temSemente;    
    }
      
    toString() {
        let comOuSem = this.temSemente ? &quot;com&quot; : &quot;sem&quot;; 
        return super.toString() + &#39; &#39; + this.cor + &#39; &#39; + comOuSem + &quot; semente&quot;;
    }
};

var banana = new Fruta(&quot;banana&quot;, &quot;amarela&quot;, false);
var uva = new Fruta(&quot;uva&quot;, &quot;roxa&quot;, true);

console.log(banana.toString()); // &quot;banana amarela sem semente&quot;
console.log(uva.toString()); // &quot;uva roxa com semente&quot;

// verificando o protótipo usado para construir o objeto uva
console.log(uva.constructor);

/* function Fruta(nome, cor, temSemente) {
      _classCallCheck(this, Fruta);

      // chamando o construtor da superclasse
      _get(Object.getPrototypeOf(Fruta.prototype), &quot;constructor&quot;, this).call(this, nome);
      this.cor = cor;
      this.temSemente = temSemente;
  } */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O JavaScript, apesar de ser potente em orientação a objetos, é por natureza uma
linguagem funcional. Por isso ele não tem um sistema de herança apropriado,
porém ele tem &lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Todo objeto em JavaScript, quando criado, tem sua definição herdada de um protótipo
(&lt;code class=&quot;inline&quot;&gt;prototype&lt;/code&gt;). Aliás esse protótipo também é um objeto que
por sua vez também tem um protótipo. Exceto pelo objeto &lt;em&gt;Object&lt;/em&gt;, que é o último protótipo
da cadeia de protótipos (&lt;a href=&quot;https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;Prototype Chain&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Protótipos são definições de funções e objetos (métodos e propriedades) e neles podemos
“atachar” métodos, que também são funções. Atachando funções em protótipos nos dá a vantagem de
compartilhar a mesma referência de funções entre os objetos criados a partir desse
protótipo.&lt;/p&gt;

&lt;p&gt;O que é mais legal em JavaScript, na minha opnião, é que ele não nos obriga a programar de uma
maneira engessada, seguindo um padrão definido por alguém, como
outras linguagens orientadas a objetos tradicionais fazem. Eu particularmete gostei
da adição do açucar sintático &lt;code class=&quot;inline&quot;&gt;class&lt;/code&gt; mesmo eu não o usando muito,
acho que fica fácil para aqueles vindos de linguagens como Java e C# iniciar com e entender
JavaScript. Eu prefiro a programação funcional do javascript, mas o que eu mais gosto no JavaScript é
a liberdade que ele nos dá para escolher o paradigma que preferirmos usar. Podemos fazer
a mesma coisa usando toda a potência da programação orientada a objetos ou apenas programação
funcional ou reativa.&lt;/p&gt;

</description>
        <pubDate>Sun, 30 Oct 2016 17:29:18 -0300</pubDate>
        <link>http://blini.io/classes-e-objetos-em-javascript</link>
        <guid isPermaLink="true">http://blini.io/classes-e-objetos-em-javascript</guid>
        
        <category>javascript</category>
        
        <category>poo</category>
        
        
        <category>javascript</category>
        
        <category>poo</category>
        
      </item>
    
      <item>
        <title>O Que não é Permitido no ‘Strict Mode’ do Javascript?</title>
        <description>&lt;p&gt;A diretiva &lt;code class=&quot;inline&quot;&gt;&quot;use strict&quot;;&lt;/code&gt; do JavaScript foi incluída no &lt;strong&gt;ECMAScript 5&lt;/strong&gt; e define
que o código JavaScript será executado em &lt;em&gt;Strict Mode&lt;/em&gt; (modo restrito), o que nos obriga a
seguir algumas regras de sintaxe para escrevermos um código mais “seguro”.&lt;/p&gt;

&lt;h2 id=&quot;porqu-strict-mode&quot;&gt;Porquê &lt;em&gt;Strict Mode&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;O JavaScript é uma linguagem extremamente dinâmica e flexível, o que nos permite escrever código
sem seguir nenhuma convenção de sintaxe e fazer coisas muito estranhas que em qualquer outra linguagem
nunca seria permitido. Como por exemplo usar uma variável sem declará-la antes.&lt;/p&gt;

&lt;p&gt;O problema é que essa liberdade toda pode causar comportamentos não esperados no código podendo
ser as vezes de difícil identificação e correção.&lt;/p&gt;

&lt;p&gt;Com o &lt;em&gt;Strict Mode&lt;/em&gt; ativado o JavaScript fica menos flexível e nos obriga a seguir algumas
regras. O interpretador do JavaScript irá sempre retornar um erro e travar a execução
do código sempre que encontrar alguma dessas más sintaxes no código. O que ele
basicamente faz é converter as más sintaxes, antes permitidas, em erros reais. Isso nos dá
mais segurança de que nosso código vai se comportar como o esperado.&lt;/p&gt;

&lt;h2 id=&quot;como-e-onde-declarar-o-stric-mode&quot;&gt;Como e Onde Declarar o Stric Mode?&lt;/h2&gt;

&lt;p&gt;O &lt;em&gt;Strict Mode&lt;/em&gt; é ativado adicionando o literal &lt;code class=&quot;inline&quot;&gt;“strict mode”;&lt;/code&gt;
no começo de scripts ou de funções e se aplica apenas ao contexto onde foi inserido.
Caso seja inserido no começo do script, será aplicado a todo o código.
Caso for incluído no começo de uma função será aplicado apenas dentro da função.&lt;/p&gt;

&lt;h2 id=&quot;as-ms-sintaxes-que-o-strict-mode-no-permite&quot;&gt;As Más Sintaxes que o &lt;em&gt;Strict Mode&lt;/em&gt; não permite&lt;/h2&gt;

&lt;h4 id=&quot;utilizar-varivel-sem-declarar&quot;&gt;Utilizar variável sem declarar&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
x = 3.14;  // isso vai retornar um erro
obj = {p1:10, p2:20}; // também vale para objetos
var y = 3.14 // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletar-variveis-ou-objeto&quot;&gt;Deletar variáveis ou objeto&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var x = 3.14;
delete x;  // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletar-funo&quot;&gt;Deletar função&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
function x(p1, p2) {}; 
delete x;  // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;duplicar-nome-de-parmetros&quot;&gt;Duplicar nome de parâmetros&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
function x(p1, p1) {}; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;nmeros-em-octal&quot;&gt;Números em Octal&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var x = 010; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;caracteres-de-escape&quot;&gt;Caracteres de Escape&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var x = \010; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;escrever-em-uma-propriedade-read-only&quot;&gt;Escrever em uma propriedade read-only&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var obj = {};
Object.defineProperty(obj, &quot;x&quot;, {value:0, writable:false});

obj.x = 3.14; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;escrever-em-uma-propriedade-get-only&quot;&gt;Escrever em uma propriedade get-only&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var obj = {get x() {return 0} };

obj.x = 3.14; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;deletar-uma-propriedade-que-no-pode-ser-deletada&quot;&gt;Deletar uma propriedade que não pode ser deletada&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
delete Object.prototype; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;usar-palavras-reservadas-como-arguments-e-eval-em-nome-de-variveis&quot;&gt;Usar palavras reservadas como ‘arguments’ e ‘eval’ em nome de variáveis&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
var eval = 3.14; // isso vai retornar um erro

var arguments = 3.14; // isso também vai retornar um erro

// Isso serve também para as palavras reservadas:
// implements
// interface
// let
// package
// private
// protected
// public
// static
// yield
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;usar-a-declarao-while&quot;&gt;Usar a declaração while&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
with (Math){x = cos(2)}; // isso vai retornar um erro
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;restrio-na-funo-eval&quot;&gt;Restrição na função eval()&lt;/h4&gt;

&lt;p&gt;A função &lt;code class=&quot;inline&quot;&gt;eval()&lt;/code&gt; não pode criar variáveis no escopo onde ela é usada&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&quot;use strict&quot;;
eval (&quot;var x = 2&quot;);
alert (x); // a variável &#39;x&#39; não existe aqui
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 24 Oct 2016 07:09:41 -0300</pubDate>
        <link>http://blini.io/o-que-nao-e-permitido-no-strict-mode-do-javascript</link>
        <guid isPermaLink="true">http://blini.io/o-que-nao-e-permitido-no-strict-mode-do-javascript</guid>
        
        <category>javascript</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Como eu diminui um Page Load de 1 minuto para 15 segundos em uma página feita com WordPress</title>
        <description>&lt;p&gt;Este foi um trabalho que eu fiz para um hostel em &lt;a href=&quot;https://www.lonelyplanet.com/hungary/budapest&quot;&gt;Budapeste - Hungria&lt;/a&gt;.
O site do hostel foi feito com WordPress e apresentava extrema lentidão no carregamento da página,
e discrepâncias e erros na responsividade do layout quando visitado em telas pequenas.&lt;/p&gt;

&lt;p&gt;O site não tinha nenhum tipo de otimização. O antigo desenvolvedor apenas instalou o WordPress, adicionou o template &lt;a href=&quot;https://themeforest.net/item/nice-hotel-wordpress-theme/2661854&quot;&gt;Nice Hostel&lt;/a&gt; e entregou
um Page Load de incríveis 1:09. Muito tempo de espera para um site onde uma das &lt;em&gt;Personas&lt;/em&gt; é
o(a) viajante com pressa para reservar um quarto, não?&lt;/p&gt;

&lt;p&gt;Pois é, a missão dada foi diminuir esse tempo de espera para poucos segundos e um carregamento
total da página para no máximo 15 segundos sob uma conexão de 1mbps com o cache desabilitado,
ou seja, quando o usuário estiver visitando o site pela primeira. Outra tarefa era melhorar a reponsividade do site.&lt;/p&gt;

&lt;p&gt;Eis o resultado:&lt;/p&gt;

&lt;iframe src=&quot;https://player.vimeo.com/video/157547302&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;Missão dada é missão cumprida&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Concordam que agora ficou muito mais rápido pra um viajante recém chegado em Budapeste,
acessar o site e reservar um quarto, certo?&lt;/p&gt;

&lt;p&gt;Enquanto agora o cara navega pelos quartos, vê as fotos e já reserva um quarto,
no site antigo o usuário ainda estaria esperando a página ser carregada, tédio!&lt;/p&gt;

&lt;p&gt;E ficou claro que a taxa de desistência do site diminuiu de 65% pra quase 0% e o hostel agora
não está perdendo mais nenhuma visita e faturando muito mais.&lt;/p&gt;

&lt;h2 id=&quot;como-foi-possvel-fazer-tamanha-melhoria-em-um-page-load&quot;&gt;Como foi possível fazer tamanha melhoria em um Page Load?&lt;/h2&gt;

&lt;p&gt;Primeiro, nenhum arquivo Javascript e CSS deve ser colocado em produção sem antes ser &lt;strong&gt;minificado e uglificado&lt;/strong&gt;.
Existem diversas maneiras de se fazer isso e vários plugins no WordPress que fazem isso pra gente.
A maneira que eu prefiro fazer é baixar e abrir localmente o tema usado no WordPress, identificar todas as dependências do front-end,
analizá-las e &lt;strong&gt;eliminar código desnecessário&lt;/strong&gt; e depois &lt;strong&gt;minificar, uglificar&lt;/strong&gt; e &lt;strong&gt;concatenar&lt;/strong&gt; com qualquer
ferramenta.&lt;/p&gt;

&lt;p&gt;Se as alterações no tema forem frequentes é recomendo automatizar esse processo com o 
&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; ou o &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;.
No caso desse projeto eu minifiquei e concatenei com ferramentas online mesmo e preservei o original (muito importante)
já que alterações futuras seriam muito pontuais. Uma das dependências que eu identifiquei e eliminei e que estava
consumindo muito tempo de carregamento, por exemplo, foi o leitor de &lt;em&gt;feeds RSS&lt;/em&gt; que esse tema possui como padrão
e que não era usado em nenhum momento pelo site, era um download desnecessário.&lt;/p&gt;

&lt;p&gt;A concatenação dos arquivos (junção dos estilos em um único arquivo CSS e dos JavaScripts em um único arquivo JS)
é recomendado pois os navegadores carregam um número limitado de arquivos por vez, em blocos,
e até que esse bloco seja totalmente carregado os outros arquivos ficam na fila de espera
e isso atrasa o carregamento da página. Então se você tem mais de 1 CSS na página é uma boa prática
juntá-los em um único CSS, assim o navegador carrega todos em uma única requisição evitando atrasos no download de outros recursos da página e
diminuindo drasticamente o carregamento. Identifiquei também muitos códigos CSS inline e incorporado em tags HTML. Removi e coloquei
em arquivos CSS externos. CSS’s inline podem reduzem o número de requisições porém aumenta o tamanho do HTML.
Em alguns casos pode ser bom, porém deve ser analizado com atenção.
Nesse projeto específico tinha muito CSS inline e incorporado, então valeu a pena criar um css externo.&lt;/p&gt;

&lt;p&gt;Depois podemos dar ao usuário uma percepção de que o site está sendo carregado mais rápido, aumentando
o tempo de resposta da renderização do HTML.
Fazemos isso &lt;strong&gt;referenciando os arquivos nos lugares certos&lt;/strong&gt; no HTML. Estilos &lt;strong&gt;CSS dentro da
tag head&lt;/strong&gt; e &lt;em&gt;scripts&lt;/em&gt; &lt;strong&gt;JavaScript no final da página&lt;/strong&gt;. O navegador
precisa fazer o download e executar cada &lt;em&gt;script&lt;/em&gt; JS e isso bloqueia o carregamento de outros recursos até
que isso seja feito pra cada &lt;em&gt;script&lt;/em&gt;. Colocando-os no final da página nós garantimos que até
chegar o momento de executar &lt;em&gt;scripts&lt;/em&gt;, a parte mais importante da página, feita somente com HTML e os estilos CSS,
já estará visível para o usuário ao invés dele ficar vendo uma tela em branco (como era o caso, mostrado no vídeo acima).&lt;/p&gt;

&lt;p&gt;Pra melhorar ainda mais esse carregamento foi feito &lt;strong&gt;compressão dos htmls e assets com GZIP&lt;/strong&gt;, todas &lt;strong&gt;imagens&lt;/strong&gt; foram
&lt;strong&gt;otimizadas&lt;/strong&gt;, configuradas para &lt;strong&gt;carregar progressivamente&lt;/strong&gt; e depois &lt;strong&gt;comprimidas&lt;/strong&gt; manualmente, usando a técnica
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lossy_compression&quot;&gt;&lt;em&gt;Lossy Compression&lt;/em&gt;&lt;/a&gt;
com o &lt;a href=&quot;https://tinyjpg.com/&quot;&gt;TinyJpg&lt;/a&gt; e o &lt;a href=&quot;https://tinypng.com/&quot;&gt;TinyPng&lt;/a&gt; e depois instalado
o plugin &lt;a href=&quot;https://br.wordpress.org/plugins/tiny-compress-images/&quot;&gt;TinyImg&lt;/a&gt; no WordPress pra que
todas as próximas imagens &lt;em&gt;“upadas”&lt;/em&gt; fossem comprimidas automaticamente.&lt;/p&gt;

&lt;p&gt;Outro grande gargalo identificado foi a imagem de fundo da página. Como era basicamente um fundo preto com
um desenho simples, feita erroneamente em um JPG grande, a solução foi extrair esse desenho, transformá-lo em um PNG pequeno, otimizá-lo
e repetí-lo no eixo x do &lt;em&gt;viewport&lt;/em&gt; junto com uma cor de &lt;em&gt;background&lt;/em&gt; preta, eliminando assim muitos &lt;em&gt;kilobytes&lt;/em&gt; de download e espera do usuário.&lt;/p&gt;

&lt;p&gt;Temas de WordPress carregam muita coisa desnecessária que muitas vezes nunca são usadas e só fazem aumentar o tempo de carregamento da página.
Esse era também o caso desse projeto, muitos recursos do tema estavam sendo carregados e nunca usados.
Foi necessário então identificar todas essas dependências e eliminá-las.
Podemos fazer isso manualmente, porém existem plugins no WordPress como o
&lt;a href=&quot;https://wordpress.org/plugins/asset-queue-manager/&quot;&gt;Asset Queue Manager&lt;/a&gt; que nos
ajudam com isso e foi usado neste caso para esse propósito.&lt;/p&gt;

&lt;p&gt;E para as bibliotecas JavaScript de terceiros é recomendado configurar execução assíncrona
com o atributo &lt;code class=&quot;inline&quot;&gt;async&lt;/code&gt; que também pode ser feita com o &lt;code class=&quot;inline&quot;&gt;defer&lt;/code&gt;, exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markup&quot;&gt;&amp;lt;script async src=&quot;https://third-party.com/resource.js&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isso faz com que o &lt;em&gt;script&lt;/em&gt; seja executado assincronamente, assim que ele estiver disponível, não bloqueando a continuação do carregamento da página. 
Em navegadores que não suportam esse atributo, existe outra maneira de fazer isso, como mostrado abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;(function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.src = &#39;https://third-party.com/resource.js&#39;;
    s.parentNode.insertBefore(g, s);
}(document, &#39;script&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É claro que você precisa tomar cuidado para não quebrar outros &lt;em&gt;scripts&lt;/em&gt; que dependem desse &lt;em&gt;script&lt;/em&gt;
pois a ordem de inserção dos &lt;em&gt;script&lt;/em&gt; na página, nesse caso, deixa de ser relevante.&lt;/p&gt;

&lt;p&gt;Outra coisa que melhora muito a performance no mobile é criar
&lt;strong&gt;versões específicas de imagens para telas pequenas&lt;/strong&gt;. O usuário que está acessando o site pelo celular 
em uma tela de 320px de largura, por exemplo, não precisa fazer o download de uma imagem com 780px de largura.
Nesse caso foram criados &lt;em&gt;breakpoints&lt;/em&gt; no CSS que carregam e exibem imagens específicas
para telas pequenas, médias e grandes.&lt;/p&gt;

&lt;p&gt;Além de tudo isso, todo o código JavaScript do tema foi refatorado e muito código refeito para
usar abordagens mais performáticas e recomendadas. Um exemplo é guardar o tamanho do array em
&lt;em&gt;loops for&lt;/em&gt; eliminando esse cálculo de ser feito em cada interação, otimizando assim a performance do JavaScript.
Isso é feito como mostrado no exemplo abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var arr = new Array(1000),
    len, i;

for (i = 0; i &amp;lt; arr.length; i++) {
  // Ruim - o tamanho precisa ser calculado 1000 vezes
}

for (i = 0, len = arr.length; i &amp;lt; len; i++) {
  // Bom - o tamanho só é calculado 1 vez e depois armazenado
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Fonte: https://browserdiet.com/pt/#cache-array-lengths&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Um site muito legal que serve como um guia definitivo criado por &lt;a href=&quot;https://zenorocha.com/&quot;&gt;Zeno Rocha&lt;/a&gt;
pra todo esse processo de melhoria de performance
é o &lt;a href=&quot;https://browserdiet.com/pt/&quot;&gt;https://browserdiet.com/pt/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;E no final de tudo isso o feedback recebido pelo cliente foi:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Man, you are the best! Thanks a lot!!!!!!!!!!!!!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You’re welcome! :)&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Sep 2016 21:27:00 -0300</pubDate>
        <link>http://blini.io/performance-no-wordpress</link>
        <guid isPermaLink="true">http://blini.io/performance-no-wordpress</guid>
        
        
        <category>wordpress</category>
        
        <category>performance</category>
        
      </item>
    
      <item>
        <title>Iniciando com Ionic</title>
        <description>&lt;p&gt;O Ionic é um framework front-end e open-source para desenvolvimento de aplicativos móveis híbridos &lt;em&gt;Cross-Platform&lt;/em&gt; escritos em HTM, CSS e JavaScript.&lt;/p&gt;

&lt;p&gt;Com o Ionic é possível escrever código uma única vez e ter um aplicativo que roda ‘nativamente’ (entre aspas pois não é
100% nativo) no iPhone, Android e Windows Phone. Isso é possível pois estes Sistemas Operacionais Móveis possuem APIs
(&lt;em&gt;Application Program Interface&lt;/em&gt;) usadas para que seus programadores desenvolvam aplicativos nativos para a plataforma.
O que o Ionic faz é, através do &lt;a href=&quot;https://cordova.apache.org/&quot;&gt;&lt;em&gt;Apache Cordova&lt;/em&gt;&lt;/a&gt;, ajudar-nos a comunicarmos com estas APIs que,
por sua vez, comunicam-se com um componente chamado Web View, usado por aplicativos nativos para visualização de páginas web
dentro do contexto dos aplicativos móveis (como um Browser qualquer). O Ionic permite que nosso aplicativo rode embarcado
dentro dessa &lt;em&gt;Web View&lt;/em&gt;, que interpreta e renderiza nosso código HTML, CSS e JavaScript, como qualquer outro navegador moderno.
O Ionic basicamente estiliza nossos componentes HTML para se parecer com os componentes nativos de cada plataforma móvel alvo,
simulando a experiência nativa do usuário final (o que seria um trabalhão fazermos na mão) e usa esse ‘navegador’ para rodar os
aplicativos e disponibiliza bibliotecas JavaScript para acessarmos o hardware e tecnologias nativas do device como câmera, GPS,
Bluetooth, etc (o que também seria um trabalhão pra fazer na mão).&lt;/p&gt;

&lt;p&gt;Como o nome sugere o aplicativo não será nativo, e sim híbrido. O Ionic empacota a aplicação em arquivos instaláveis para cada
plataformas móvel que então pode ser publicado nas principais lojas de aplicativos móveis e ser distribuída para o público-alvo.
Ele também nos oferece excelente produtividade e serviços como o &lt;em&gt;Ionic Platform&lt;/em&gt; que ajuda em tudo que uma aplicação precisa ter
(push notifications, autenticação, etc), Planos Empresariais, e um CLI (&lt;em&gt;Command-line Interface&lt;/em&gt;) que te dá muita produtividade
através de linhas de comando.&lt;/p&gt;

&lt;p&gt;E é claro que, como o código que você vai escrever é puramente HTML, CSS e JavaScript, você poderá rodar e visualizar a aplicação
no seu navegador web preferido. E pra fecharmos o assunto ‘aplicativos híbridos’, com esse mesmo código, excluindo a parte do
Cordova, pode-se criar uma aplicação Desktop &lt;em&gt;Cross-Platform&lt;/em&gt;, com ajuda de tecnologias como o &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt;,
que empacota código Web para rodar em Mac, Windows e Linux. O Ionic nos ajuda no mundo Mobile e o Electron no mundo Desktop, e
juntando as duas tecnologias você pode ter uma aplicação 100% híbrida e &lt;em&gt;Cross-Platform&lt;/em&gt; Mobile e Desktop.&lt;/p&gt;

&lt;p&gt;Eu pessoalmente não recomendaria uma abordagem tão híbrida dessa, já que cada plataforma tem suas peculiaridades e algumas vezes
exige nossa atenção especial para criar códigos personalizados. Lembre-se, experiência do usuário em primeiro lugar! Isso foi
apenas para ilustrar o que realmente é uma aplicação híbrida. Entretanto, no mundo Mobile, o Ionic faz o serviço muito bem feito.&lt;/p&gt;

&lt;p&gt;O Ionic é baseado no AngularJs e por isso você irá escrever directivas do Angular no seu HTML e usar os seus módulo: &lt;em&gt;services,
controllers, factories, routes&lt;/em&gt;, etc. No Angular 2 muita coisa mudará e o Ionic 2 está sendo construído em cima dele, porém até
o momento da escrita desse artigo, o Ionic 2 ainda está em fase beta e o Angular 2 em um RC (&lt;em&gt;Release Candidate&lt;/em&gt;) que ainda está
muito instável, por isso a versão 2 será assunto de futuros artigos.&lt;/p&gt;

&lt;h2 id=&quot;preparando-o-ambiente&quot;&gt;Preparando o Ambiente&lt;/h2&gt;

&lt;p&gt;Os softwares e tecnologias necessários para criar aplicativos com o Ionic são os seguintes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Node.js&lt;/strong&gt; - Requerido pelo Ionic para uso do CLI e em tarefas de build&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NPM&lt;/strong&gt; (instalado junto com o Node.js) - Para gerenciarmos nossas dependências&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt; - Para o Ionic fazer o scaffolding dos templates iniciais, e também usado pelo Bower&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bower&lt;/strong&gt; - Para gerenciar nossas dependências no front-end&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cordova e Ionic CLI&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Você também vai precisar de um editor de texto. Eu uso e recomendo o VS Code (https://code.visualstudio.com) que é um excelente fork do Atom com fantático suporte ao JavaScript.
Eu também recomendaria o &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;, porém você pode usar qualquer um de sua preferência.&lt;/p&gt;

&lt;h3 id=&quot;instalando-o-nodejs-e-npm&quot;&gt;Instalando o Node.js e npm&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Acesse o site do Node.js em http://nodejs.org&lt;/li&gt;
  &lt;li&gt;Clique no botão de download para baixar a versão específica para o seu SO&lt;/li&gt;
  &lt;li&gt;Instale o Node.js clicando no instalador baixado&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Isso irá instalar a versão escolhida do Node.js e o NPM.&lt;/p&gt;

&lt;p&gt;Para verificar a instalação, abra o terminal do seu computador e digite:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;node -v&lt;/code&gt; e &lt;code class=&quot;inline&quot;&gt;npm -v&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se a instalação foi um sucesso isso retornará a versão instalada de cada um:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/node-npm-version-check.jpg&quot; alt=&quot;Verificando a instalação do Node.js e do npm&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instalando-o-git&quot;&gt;Instalando o Git&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Acesse a página do Git no site: https://git-scm.com/download&lt;/li&gt;
  &lt;li&gt;Clique no botão de download compatível com o SO da sua máquina&lt;/li&gt;
  &lt;li&gt;Instale o Git clicando no instalador baixado&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para verificar a instalação do Git, digite no terminal:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;git --version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso retornará a versão instalada caso o Git tenha sindo instalado com sucesso.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/git-version-check.jpg&quot; alt=&quot;Verificando a versão do Git instalado&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instalando-o-bower&quot;&gt;Instalando o Bower&lt;/h3&gt;

&lt;p&gt;O Bower é instaldo através do NPM (&lt;em&gt;Node Package Manager&lt;/em&gt;), o gerenciador de pacotes do Node.js, aquele que é instalado junto com o Node.js.&lt;/p&gt;

&lt;p&gt;Para isso precisamos abrir novamente o terminal e digitar o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;npm install -g bower&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Esse comando instala o módulo do Node chamado Bower globalmente (&lt;em&gt;-g&lt;/em&gt;). No linux você deve instalar digitando:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;sudo npm install bower&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Mais uma vez, verificando a instalação:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;bower -v&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/bower-version-check.jpg&quot; alt=&quot;Verificando a instalação do Bower no terminal&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instalando-o-cordova-e-o-ionic-cli&quot;&gt;Instalando o Cordova e o Ionic CLI&lt;/h3&gt;

&lt;p&gt;O Ionic CLI engloba o Cordova CLI com comandos adicionais, e para isso precisamos também instalar o Cordova globalmente, usaremos
o npm mais uma vez.&lt;/p&gt;

&lt;p&gt;Novamente, nada complicado, abra o terminal e digite:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;npm install -g cordova ionic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Isso baixará e instalará globalmente em sua máquina o Cordova e o Ionic CLI no mesmo comando. Pode demorar um pouco
dependendo da sua conexão.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/instalando-cordova-e-ionic-cli.jpg&quot; alt=&quot;Instalando Cordova e Ionic CLI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Verifique a instalação digitando no terminal&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;cordova -v&lt;/code&gt; e &lt;code class=&quot;inline&quot;&gt;ionic -v&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/cordova-e-ionic-cli-version-check.jpg&quot; alt=&quot;Verificando a instalação do Cordova e Ionic CLI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pronto, o Ionic CLI está instalado. Agora podemos digitar ionic no terminal e visualizar os comandos disponíveis para ter uma ideia do que podemos fazer via de linha de comando:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;ionic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/ionic-cli-commands.jpg&quot; alt=&quot;Visualizando os comandos disponíveis no Ionic CLI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agora estamos prontos pra continuar!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;iniciando-a-aplicao&quot;&gt;Iniciando a Aplicação&lt;/h2&gt;

&lt;p&gt;O Ionic possui 5 templates disponíveis no GitHub para você iniciar uma aplicação:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Blank&lt;/strong&gt;: Template vazio com apenas uma página.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Tabs&lt;/strong&gt;: Aplicação de exemplo usando o sistema de navegação em abas do Ionic.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Side Menu&lt;/strong&gt;: Mesma aplicação de exemplo do Tabs porém, ao invés de abas, um sistema de navegação em menu lateral deslizante.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Maps&lt;/strong&gt;: Template com apenas uma página com um mapa renderizado e Geo Localização codificada.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sales Force&lt;/strong&gt;: Template com com código integrado à API do CRM da &lt;em&gt;Sales Force&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para fazer o scaffolding da sua primeira app e rodá-la é muito simples, abra o terminal e digite:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;ionic start -a &quot;Minha App&quot; -i minhaapp minha-app blank&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;onde&quot;&gt;Onde:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;-a &quot;Minha App&quot;&lt;/code&gt; é o nome amigável do seu aplicativo&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;-i minhaapp&lt;/code&gt; é o ID aplicativo&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;minha-app&lt;/code&gt; é o nome da pasta ou o local onde o aplicativo com o template escolhido será gerado&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;blank&lt;/code&gt; é o template escolhido entre as opções &lt;em&gt;blank&lt;/em&gt;, &lt;em&gt;tabs&lt;/em&gt;, &lt;em&gt;sidemenu&lt;/em&gt;, &lt;em&gt;maps&lt;/em&gt; e &lt;em&gt;salesforce&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ou use a forma reduzida: &lt;code class=&quot;inline&quot;&gt;ionic start minha-app blank&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;onde-1&quot;&gt;Onde:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;minha-app&lt;/code&gt; é o ID aplicativo&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;inline&quot;&gt;blank&lt;/code&gt; é o template escolhido entre as opções &lt;em&gt;blank&lt;/em&gt;, &lt;em&gt;tabs&lt;/em&gt;, &lt;em&gt;sidemenu&lt;/em&gt;, &lt;em&gt;maps&lt;/em&gt; e &lt;em&gt;salesforce&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/initializing-cordova-project.jpg&quot; alt=&quot;Inicializando a aplicação sidemenu do Ionic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aguarde um pouquinho, o Ionic irá baixar os arquivos hospedados no GitHub para a sua máquina. Depois da aplicação inicializada e o &lt;em&gt;scaffold&lt;/em&gt; do template feito, acesse a pasta onde o app foi gerado digitando no terminnal:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;cd minha-app&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/acessando-a-pasta.jpg&quot; alt=&quot;Acessando a pasta onde reside o aplicativo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para visualizar o aplicativo é muito simples, lembra que o aplicativo desenvolvido com o Ionic roda embarcado em um navegador?
Pois é, basta levantar um servidor &lt;em&gt;http&lt;/em&gt; e acessar pelo navegador. O Ionic faz isso pra gente automaticamente, basta digitar no terminal:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;ionic serve&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Com esse comando o Ionic irá levanta um servidor &lt;em&gt;http&lt;/em&gt; na porta 8100 e abrir o navegador padrão do sua máquina com o app rodando.&lt;/p&gt;

&lt;p&gt;Ele ainda mostra alguns comandos úteis no terminal:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/servidor-rodando.jpg&quot; alt=&quot;Servidor rodando na porta 8100 e alguns comandos úteis&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Caso ocorra algum erro, tente rodar em uma porta mais alta, colocando o número da porta no final do comando, assim:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;ionic serve -p 9000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/ezgif-1287516005-3.gif&quot; alt=&quot;Aplicativo rodando no navegador web&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para destruir o servidor e destravar o terminal digite:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;inline&quot;&gt;crtl + c&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;No próximo artigo vamos ver um pouco sobre a estrutura dos arquivos e arquitetura do projeto gerado pelo &lt;em&gt;scaffolding&lt;/em&gt; do Ionic
e como personalizar o aplicativo. Assim como configurar as plataformas iOS e Android pra emular nosso aplicativo, rodar o
aplicativo diretamente no celular e usar o &lt;em&gt;Ionic View&lt;/em&gt; para mostrar o aplicativo para os seus clientes e amigos e receber &lt;em&gt;feedbacks&lt;/em&gt;.&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Jun 2016 21:27:00 -0300</pubDate>
        <link>http://blini.io/iniciando-com-ionic</link>
        <guid isPermaLink="true">http://blini.io/iniciando-com-ionic</guid>
        
        
        <category>ionic</category>
        
        <category>javascript</category>
        
        <category>mobile</category>
        
      </item>
    
      <item>
        <title>Aplicativos Móveis com JavaScript: Ionic, React Native e NativeScript. Qual escolher?</title>
        <description>&lt;p&gt;O mundo dos aplicativos móveis é muito diferente do mundo Web. Para nós desenvolvedores Web que quisermos entrar nesse mundo precisamos estar concientes dessas diferenças e algumas complexidades como gerenciamento de memória, concorrências entre threads, deploy nas lojas de aplicativos, experiência do usuário na hora do download/instalação, capacidades de cada plataforma mobile e experiência do usuário são uma delas.&lt;/p&gt;

&lt;p&gt;Felizmente no mundo dos Aplicativos Web Modernos temos visto o surgimento de vários frameworks que nos permitem abstrair todas essas complexidades, focarmos no código e desenvolvermos aplicativos móveis com o que já está em nossa caixa de ferramentas: HTML/XML, CSS e JavaScript. E o PhoneGap/Cordova também está ai pra nos ajudar.&lt;/p&gt;

&lt;p&gt;Em um ecossistema com várias opções qual tecnologia escolher entre as diversas disponíveis do mercado? Vamos analizar três delas aqui:&lt;/p&gt;

&lt;h1 id=&quot;ionic&quot;&gt;Ionic&lt;/h1&gt;

&lt;p&gt;O Ionic é um framework baseado no Angular (um dos mais fortes frameworks de JavaScript do mercado) para desenvolvimento de aplicativos móveis com tecnologias Web. Com o Ionic você consegue desenvolver aplicativos móveis híbridos com HTML, CSS e JavaScript para Android, iOS e Windows Phone.&lt;/p&gt;

&lt;p&gt;Os aplicativos desenvolvidos com Ionic não são nativos mas se parecem e agem como tal, o que o Ionic faz é estilizar o HTML que você escreve para se parecer com os componentes UI nativos de cada plataforma móvel e usa o Apache Cordova para fazer tais componentes se comportarem como nativos comunicando-se com as APIs nativas.&lt;/p&gt;

&lt;p&gt;O ionic foi criado em 2013 pela Drifty, empresa criada por 2 amigos de infância com a missão de facilitar o desenvolvimento Web e mobile e mais tarde viram a grande oportunidade de ajudar desenvolvedores a criar aplicativos móveis &lt;i&gt;Cross-Platform&lt;/i&gt; usando padrões Web modernos, criaram o Ionic e receberam um investimento inicial de $1 milhão pra continuarem o desenvolvimento e hoje o Ionic é mais popular framework de desenvolvimento de aplicativos móveis do mercado com, segundo um dos fundadores, 200 apps sendo criadas com Ionic todos os dias. A comunidade realmente é gigante e você encontra suporte pra qualquer dúvida e bug que surgir durante o desenvolvimento da sua app com uma simples e rápida busca no Google.&lt;/p&gt;

&lt;h3 id=&quot;vantagens&quot;&gt;Vantagens:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Baseado no Angular&lt;/li&gt;
  &lt;li&gt;Write once, run anywhere (escreva uma vez, rode em qualquer lugar).&lt;/li&gt;
  &lt;li&gt;A curva de aprendizagem é muito pequena, você constrói um app com pouco esforço e complexidade&lt;/li&gt;
  &lt;li&gt;Pode visualizar seu aplicativo direto no Browser durante o desenvolvimento sem a necessidade de ficar emulando dispositivos.&lt;/li&gt;
  &lt;li&gt;A comunidade é enorme, você consegue suporte e resolve bugs muito rápido&lt;/li&gt;
  &lt;li&gt;Muito bem documentado e vasto número de tutoriais espalhados pela internet&lt;/li&gt;
  &lt;li&gt;Plano de suporte para times e empresas que ajuda no desenvolvimento, testes, empacotamento, publicacão e distribuição&lt;/li&gt;
  &lt;li&gt;Manutenção de código centralizada já que o código que roda no Android é o mesmo que roda no iOS e Windows Phone&lt;/li&gt;
  &lt;li&gt;Mais leve&lt;/li&gt;
  &lt;li&gt;Ecossistema de ferramentas e serviços como Inonic View, Push Notification, User Authentication, Live Deployment, Native App Package, Ionic Creator, Analytics Service e um CLI para scaffoldind de templates e comandos extremamente úteis na hora do desenvolvimento, testes e distribuição&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;desvantagens&quot;&gt;Desvantagens&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Problemas de performance em alguns ambientes, principalmente em Androids mais antigos&lt;/li&gt;
  &lt;li&gt;Pode apresentar discrepâncias entre componentes UI que você escreve e o que é renderizado na plataforma nativa&lt;/li&gt;
  &lt;li&gt;Não é seguro que funcione bem em 100% dos dispositivos&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;concluso&quot;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;O ionic é um framework incrível que te permite criar aplicativos móveis incríveis de maneira muito rápida e tem uma comunidade enorme pronta pra te ajudar, o Ionic modifica automaticamente a aparência do app dependendo da plataforma que o usuário está para funcionar de maneira fiel à experiência que o usuário está acostumado. Ele é renderizado e roda embarcado dentro de um navegador (webview) pré-existente no SO dos smartphones e que não é perceptível para o usuário final, rodando como se fosse nativo. &lt;/p&gt;

&lt;p&gt;Por não ser 100% nativo, pode apresentar problemas de performance principalmente em Androids mais antigos (inferiores ao 4.0) com pouco poder de processamento. O que não é um grande problema, no passado essa abordagem era impeditiva, atualmente a diferença de performance comparado ao nativo é mínima porém notável em alguns ambientes. Leve em conta também que hoje em dia cada vez mais vemos celulares munidos com hardware de alta capacidade de processamento que renderiza jogos que muitos computadores desktop não é capaz de renderizar e tecnologias como &lt;a href=&quot;https://crosswalk-project.org/&quot;&gt;CrossWalk Project&lt;/a&gt;, que resolve o problema de performance em webviews em Androids mais antigos. Por esses motivo o Ionic não terá problema nenhum em renderizar um simples aplicativo que usa pouco hardware. Porém, como dito, funciona bem para aplicativos mais simples e de pequeno porte, que usa poucas funcionalidades nativas, onde a performance não é mandatória, ou o prazo desenvolvimento for curto, ou se for para prototipação ou o orçamento é baixo. Vale ressaltar que no Ionic 2 a história é outra, a equipe do Ionic está fazendo um trabalho incrível no Ionic 2 porém a forma de desenvolver será totalmente diferente já que este será baseado no Angular 2.&lt;/p&gt;

&lt;p&gt;*Ionic Framework via Drifty:**&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Free and open source, Ionic offers a library of mobile-optimized HTML, CSS and JS components, gestures, and tools for building highly interactive apps. Built with Sass and optimized for AngularJS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Site oficial: &lt;a href=&quot;http://ionicframework.com&quot;&gt;http://ionicframework.com&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;react-native&quot;&gt;React Native&lt;/h1&gt;

&lt;p&gt;O React Native é baseado no React, o framework front-end criado pelo Facebook e usado no Facebook. O React é o competidor direto do Angular em relação à popularidade, tutoriais e comunidade. É um excelente framework e muito performático, como pode ser notado usando o Facebook. No React Native não é diferente, os aplicativos desenvolvidos com ele não apresentam problemas de performance já que eles são nativos! O React Native nos permite desenvolver aplicativos móveis com HTML, CSS e JavaScript. O código é compilado pra código nativo (Java, Object-C, Swift) entregando uma experiência nativa ao usuário final.&lt;/p&gt;

&lt;p&gt;Não é uma plataforma de desenvolvimento de aplicativos híbridos. Diferente do Ionic a filosofia do React Native é “learn once, write anywhere” (aprenda uma vez, escreva em qualquer lugar), isso significa que você terá que escrever um código pra iOS e outro para Android, tendo que manter dois códigos diferenrentes, o que implica em maior custo em desenvolvimento e manutenção, o que é compensado na melhor organização de código que o React oferece e pelos aplicativos serem nativos sem gargalos de performance e discrepâncias entre componentes UI que os aplicativos que usam webview apresentam.&lt;/p&gt;

&lt;h3 id=&quot;vantagens-1&quot;&gt;Vantagens:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Tem o Facebook por trás&lt;/li&gt;
  &lt;li&gt;Baseado no React - Grande comuinidade e tutoriais espalhados pela internet&lt;/li&gt;
  &lt;li&gt;Aplicativos com excelente performance no Android e iOS&lt;/li&gt;
  &lt;li&gt;Experiência nativa para o usuário final&lt;/li&gt;
  &lt;li&gt;Manutenção do código facilitada em projetos mais complexos devido à organização do mesmo&lt;/li&gt;
  &lt;li&gt;Roda nativo, você escreve os components UI em React e eles são compilados em componentes UI nativos&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;desvantagens-1&quot;&gt;Desvantagens:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Mais difícil de aprender e começar&lt;/li&gt;
  &lt;li&gt;Não é híbrido. Precisa reescrever o código pra cada plataforma&lt;/li&gt;
  &lt;li&gt;Escrever e manter códigos diferentes para o mesmo aplicativo em iOS e Androidd&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;concluso-1&quot;&gt;Conclusão:&lt;/h3&gt;

&lt;p&gt;O React Native é uma excelente opção, eu o recomendo para aplicativos mais complexos no qual performance é extremamente importante. O getting start dele não é tão simples como o Ionic, a curva de aprendizado é maior, você terá que se esforçar mais dedicando mais tempo no desenvolvimento e aprendizado e instalando SDK’s e configurando o ambiente que ele requer para emular e testar aplicativos no seu computador. Além disso se o seu aplicativo precisa rodar no Android e iOS você terá que escrever dois códigos e depois manter esses dois códigos, na minha opnião isso é o que mais fere a proposta dos aplicativos modernos: O mantra &lt;i&gt;Cross-Platform&lt;/i&gt; “write once, run anywhere”. O react Native ao contrário divulga a proposta “learn once, write anywhere”. O que também não é um grande problema já que não temos muito o que fazer se quisermos aplicativos extremamente otimizados e performáticos para a plataforma alvo.&lt;/p&gt;

&lt;p&gt;Uma introdução do React Native (em inglês): &lt;a href=&quot;https://www.youtube.com/watch?v=KVZ-P-ZI6W4&quot;&gt;https://www.youtube.com/watch?v=KVZ-P-ZI6W4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;React Native via time do React Native&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;React Native enables you to build world-class application experiences on native platforms using a consistent developer experience based on JavaScript and React. The focus of React Native is on developer efficiency across all the platforms you care about — learn once, write anywhere. Facebook uses React Native in multiple production apps and will continue investing in React Native.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Site oficial: &lt;a href=&quot;https://facebook.github.io/react-native/&quot;&gt;https://facebook.github.io/react-native/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;nativescript&quot;&gt;NativeScript&lt;/h1&gt;

&lt;p&gt;O NativeScript é um framework &lt;i&gt;Cross-Platform&lt;/i&gt; que une, na minha opnião, o melhor dos dois concorrentes acima: O mantra “write once, run anywhere” do Ionic e a compilação pra código nativo do React Native. Isso significa que com o NativeScript você escreverá um único código com tecnologias Web e ele compilará esse único código para código nativo para iOS, Android e Windows Phone. Ele oferece todas as vantagens de ter um app nativo como performance e experiência do usuário escrevendo e mantendo um único código com JavaScript! Mazing!&lt;/p&gt;

&lt;p&gt;A única diferença que pode ser um ponto negativo é que ele não usam HTML, ao invés disso você terá que escrever suas views em XML. O que mais uma vez não é um grande problema pois as tags XML são tags parecidas com as do HTML e nós como desenvolvedores estamos acostumados com XML.&lt;/p&gt;

&lt;p&gt;O time de desenvolvimento do NativeScript foi formado em 2010 dentro da Tekerik inicialmente para desenvolvimento de components nativos para ser usados em aplicativos para o Windows Phone 7 que acabara de ser lançado. Após vários aplicativos lançados usando os componentes criados por eles, eles partiram para iOS e Android e identificaram a necessidade que as empresas e programadores têm em desenvolver o mesmo aplicativo para iOS, Android e Windows Phone gerando três códigos que fazem a mesma coisa aumentando e muito o custo de desenvolvimento, manutenção e evolução dos códigos que existiam pra resolver o mesmíssimo problema.&lt;/p&gt;

&lt;p&gt;A necessidade era escrever e manter um único código para criar aplicativos móveis nativos para serem disponibilizados na três maiores lojas de aplicativos sem comprometer a experiência do usuário. No meio de 2014 eles lançaram o NativeScript com a proposta de atender essa necessidade.&lt;/p&gt;

&lt;h3 id=&quot;vantagens-2&quot;&gt;Vantagens:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Write once, run everywhere. Escreva uma vez rode em qualquer lugar nativamente!&lt;/li&gt;
  &lt;li&gt;CLI para scaffoldind de templates e comandos extremamente úteis na hora do desenvolvimento, testes e distribuição&lt;/li&gt;
  &lt;li&gt;App nativa sem problema de performance&lt;/li&gt;
  &lt;li&gt;Preserva a experiência nativa do usuário&lt;/li&gt;
  &lt;li&gt;Compila JavaScript para código nativo em iOS e Android (Windows Phone em breve)&lt;/li&gt;
  &lt;li&gt;Pode ser usado com Angular2 junto com TypeScript ou apenas em JavaScript Puro&lt;/li&gt;
  &lt;li&gt;Manutenção e suporte em apenas um único código&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;desvantagens-2&quot;&gt;Desvantagens&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Projeto relativamente novo, comunidade relativamente pequena&lt;/li&gt;
  &lt;li&gt;Poucos tutorias, casos de uso e issues no Github e Stack Overflow&lt;/li&gt;
  &lt;li&gt;Mercado ainda pequeno&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;concluso-2&quot;&gt;Conclusão:&lt;/h3&gt;

&lt;p&gt;Manter mais de um código para o mesmo aplicativo não é muito produtivo e requer mais investimento em tecnologia, IDE, conhecimento, sistemas operacionais e APIs e mesmo assim, devido à necessidade de manter diversos códigos, muitas vezes aplicativos que deveriam se comportar da mesma maneira nas diferentes plataformas acabam tendo versões e funcionalidades diferentes.&lt;/p&gt;

&lt;p&gt;O NativeScript possibilita publicarmos aplicativos móveis nativos nas três principais lojas de aplicativos escrevendo código com tecnologias web (XML, JavaScript e CSS) sem comprometermos a experiências nativa dos nosssos usuários, cada um em sua plataforma. O código será o mesmo para os três aplicativos. Ganhamos assim produtividade, eliminados tempo, custos e complexidade na detecção e suporte em bugs, erros e evolução do aplicativo em todas as plataformas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NativeScript via Telerik:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NativeScript enables developers to build native apps for iOS and Android while sharing the application code across the platforms. When building the application UI, developers use our libraries, which abstract the differences between the native platforms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Site oficial: &lt;a href=&quot;http://www.telerik.com/nativescript&quot;&gt;http://www.telerik.com/nativescript&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Conferência do time do NativeScript na TelerikNEXT: &lt;a href=&quot;https://www.youtube.com/watch?v=HWboi_9aba8&quot;&gt;https://www.youtube.com/watch?v=HWboi_9aba8&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Jun 2016 19:48:00 -0300</pubDate>
        <link>http://blini.io/aplicativos-moveis-com-javascript-ionic-react-native-e-nativescript</link>
        <guid isPermaLink="true">http://blini.io/aplicativos-moveis-com-javascript-ionic-react-native-e-nativescript</guid>
        
        
        <category>ionic</category>
        
        <category>javascript</category>
        
        <category>nativescript</category>
        
        <category>react native</category>
        
      </item>
    
  </channel>
</rss>
